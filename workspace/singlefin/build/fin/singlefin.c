/*
 *  Single source autogenerated distributable for SingleFin 1.0.0.
 *
 *  Git commit b06ae17a88d4b8f22b0bf8bdd713428969f4dbdc (b06ae17-dirty).
 *  Git branch single-header.
 *
 *  See SingleFin AUTHORS.rst and LICENSE.txt for copyright and
 *  licensing information.
 */

/* LICENSE.txt */

/*

	Author: Nikolas Karakotas

	Wrap the functions:
	-Wl,--wrap,malloc -Wl,--wrap,free -Wl,--wrap,realloc -Wl,--wrap,calloc
	
 */
 
/* #include fin_internal.h */
/*
 *  Top-level include file to be used for all (internal) source files.
 *
 *  Source files should not include individual header files, as they
 *  have not been designed to be individually included.
 */

#if !defined(FIN_INTERNAL_H_INCLUDED)
#define FIN_INTERNAL_H_INCLUDED

/*
 *  The 'singlefin.h' header provides the public API, but also handles all
 *  compiler and platform specific feature detection, SingleFin feature
 *  resolution, inclusion of system headers, etc.  These have been merged
 *  because the public API is also dependent on e.g. detecting appropriate
 *  C types which is quite platform/compiler specific especially for a non-C99
 *  build.  The public API is also dependent on the resolved feature set.
 *
 *  Some actions taken by the merged header (such as including system headers)
 *  are not appropriate for building a user application.  The define
 *  FIN_COMPILING_SINGLEFIN allows the merged header to skip/include some
 *  sections depending on what is being built.
 */

#define FIN_COMPILING_SINGLEFIN
#include "singlefin.h"




/* #include fin_debug.h */
#if !defined(FIN_API_DEBUG_H_INCLUDED)
#define FIN_API_DEBUG_H_INCLUDED

/** lower two bits indicate debug level
 * - 0 all
 * - 1 warning
 * - 2 serious
 * - 3 severe
 */
#define TX_DBG_LEVEL_ALL     0x00
#define TX_DBG_LEVEL_OFF     TX_DBG_LEVEL_ALL 	/* compatibility define only */
#define TX_DBG_LEVEL_WARNING 0x01 				/* bad checksums, dropped packets, ... */
#define TX_DBG_LEVEL_SERIOUS 0x02 				/* memory allocation failures, ... */
#define TX_DBG_LEVEL_SEVERE  0x03
#define TX_DBG_MASK_LEVEL    0x03


/** flag DEBUGF to enable that debug message */
#define TX_DBG_ON            0x80U
/** flag_DEBUGF to disable that debug message */
#define	TX_DBG_OFF           0x00U

#ifndef TX_DBG_NOASSERT
#define TX_ASSERT(message, assertion) do { if(!(assertion)) \
		printf( __FILE__ " " message  "\n"); \
	} while(0)
#else
#define TX_ASSERT(message, assertion)
#endif

#define TX_ERROR(message, expression, handler) do { if (!(expression)) { \
  TX_DEBUGF(TX_DBG_ON|TX_DBG_LEVEL_SEVERE,message); handler;}} while(0)


#ifdef TX_DEBUG
#define TX_DEBUGF(debug,message) do { \
							 if ( \
								   ((debug) & TX_DBG_ON) && \
								   ((debug) & TX_DBG_TYPES_ON) && \
								   ((signed short)((debug) & TX_DBG_MASK_LEVEL) >= TX_DBG_MIN_LEVEL)) { \
								 printf message; \
							   } \
							 } while(0)
#else 
#define TX_DEBUGF(debug,message)
#endif



#endif  /* FIN_API_DEBUG_H_INCLUDED */
/* #include fin_debug_opt.h */
#if !defined(FIN_API_DEBUG_OPT_H_INCLUDED)
#define FIN_API_DEBUG_OPT_H_INCLUDED

#ifdef TX_USER_DEBUG_OPT
//#include TX_USER_DEBUG_OPT add sneppet
#else
#ifndef TX_DBG_TYPES_ON
#define TX_DBG_TYPES_ON               TX_DBG_OFF
#endif
#ifndef TX_DBG_MIN_LEVEL
#define TX_DBG_MIN_LEVEL              TX_DBG_MASK_LEVEL
#endif
#endif

#ifndef MALLOC_DBG
#define MALLOC_DBG		(TX_DBG_OFF)
#endif

#ifndef ITF_DBG
#define ITF_DBG			(TX_DBG_OFF)
#endif

#ifndef DSS_DBG
#define DSS_DBG			(TX_DBG_OFF)
#endif

#endif  /* FIN_API_DEBUG_OPT_H_INCLUDED */
/* #include fin_cli.h */
#if !defined(FIN_API_CLI_H_INCLUDED)
#define FIN_API_CLI_H_INCLUDED

#define STDIO_IN_MAX 256
#define STDIO_CMD_MAX 25
#define STDIO_CMD_ARGS_MAX 6


#endif  /* FIN_API_CLI_H_INCLUDED */
/* #include fin_dss.h */
#if !defined(FIN_API_DSS_H_INCLUDED)
#define FIN_API_DSS_H_INCLUDED

#define DSS_ADDR_SIZE 48

/* Number of simultaneously dss data calls supported */
#define DSS_CONCURRENT_NUM	4


#define __FIN_DSS_NOTIFY__ fin_dss_notify_t notify


extern fin_dss_ctx_t *dss_ctx_store[DSS_CONCURRENT_NUM];

#endif  /* FIN_API_DSS_H_INCLUDED */
/* #include fin_gpio.h */
#if !defined(FIN_API_GPIO_H_INCLUDED)
#define FIN_API_GPIO_H_INCLUDED

struct gpio_list_entry {
    const char *key;
    uint32_t value;
 };




#endif  /* FIN_API_GPIO_H_INCLUDED */
/* #include fin_http_client.h */
#if !defined(FIN_API_HTTP_H_INCLUDED)
#define FIN_API_HTTP_H_INCLUDED

#define HTTP_CLIENT_SESSIONS_MAX	1
#define HTTP_CLIENT_BYTE_POOL_SIZE		2048*HTTP_CLIENT_SESSIONS_MAX
#define HTTP_CLIENT_BODY_LEN_MAX		1024
#define HTTP_CLIENT_HEADER_LEN_MAX	512
#define HTTP_CLIENT_TIMEOUT		10000 // secs

#define HTTP_CLIENT_EVT_FINISHED (1 >> 0)
  /**< HTTP response -- response was received completely. */
#define HTTP_CLIENT_EVT_ERROR_SERVER_CLOSED (1 >> 1)
  /**< HTTP response error -- the server closed the connection. */
#define HTTP_CLIENT_EVT_ERROR_RX_PROCESS (1 >> 2)
  /**< HTTP response error -- response is processing. */
#define HTTP_CLIENT_EVT_ERROR_RX_HTTP_HEADER (1 >> 3)
  /**< HTTP response error -- header is processing. */
#define HTTP_CLIENT_EVT_ERROR_INVALID_RESPONSECODE (1 >> 4)
  /**< HTTP response error -- invalid response code. */
#define HTTP_CLIENT_EVT_ERROR_CLIENT_TIMEOUT (1 >> 5)
  /**< HTTP response error -- timeout waiting for a response. */
#define HTTP_CLIENT_EVT_ERROR_NO_BUFFER (1 >> 6)
  /**< HTTP response error -- memory is unavailable. */
#define HTTP_CLIENT_EVT_CONNECTION_CLOSED (1 >> 7)
  /**< HTTP response -- connection is closed. */
#define HTTP_CLIENT_EVT_ERROR_CONNECTION_CLOSED (1 >> 8)
  /**< HTTP response error -- connection is closed. */
#define HTTP_CLIENT_EVT_MORE_DATA (1 >> 9)

typedef struct http_entry_list {
	struct list_head head;
	char *data;
	uint32_t data_len;
	char *header;
	uint32_t header_len;
	uint32_t code;
} http_client_entry_t;




#endif  /* FIN_API_HTTP_H_INCLUDED */
/* #include fin_i2c.h */
#if !defined(FIN_API_I2C_H_INCLUDED)
#define FIN_API_I2C_H_INCLUDED

#define I2C_DEFAULT_FREQ	100  // 100kHz

struct i2c_list_entry {
    const char *key;
    uint32_t value;
 };


#endif  /* FIN_API_I2C_H_INCLUDED */

/* #include fin_spi.h */
#if !defined(FIN_API_SPI_H_INCLUDED)
#define FIN_API_SPI_H_INCLUDED

struct spi_list_entry {
    const char *key;
    uint32_t value;
 };


#define SPI_DEFAULT_FREQ	1000000UL  // 1MHz, this is the min and anything less will return error when spi_config




#endif  /* FIN_API_SPI_H_INCLUDED */

/* #include fin_adc.h */
#if !defined(FIN_API_ADC_H_INCLUDED)
#define FIN_API_ADC_H_INCLUDED



#endif  /* FIN_API_ADC_H_INCLUDED */

/* #include fin_uart.h */
#if !defined(FIN_API_UART_H_INCLUDED)
#define FIN_API_UART_H_INCLUDED



#endif  /* FIN_API_UART_H_INCLUDED */


#endif  /* FIN_INTERNAL_H_INCLUDED */


typedef struct malloc_size{
	uint32_t addr;
	uint16_t signature;
	uint16_t size;
} malloc_size_t __attribute__((packed));

#define MALLOC_HEAD(P) (malloc_size_t*)(P - sizeof(malloc_size_t))

/*
	Code and RAM footprint
	For a "Hello world" example:

	Config	Code footprint (kB)	Startup RAM (kB)
	thumb default	146	73
	thumb lowmem	96	26
	thumb full lowmem	120	1.5
	x86 default	176	74
	x86 lowmem	121	27
	x86 full lowmem	146	1.5

*/

TX_BYTE_POOL *byte_malloc_mem_pool = NULL;

#ifndef TX_MALLOC_MEM_SIZE
#define TX_MALLOC_MEM_SIZE 32
#endif


#define MALLOC_BYTE_POOL_SIZE 1024*TX_MALLOC_MEM_SIZE 
/* 
*	In libc's malloc(x), the function is said to return 
*  	a pointer to a memory region of at least x bytes and the pointer is aligned to 8 bytes
*/
UCHAR mem_heap[MALLOC_BYTE_POOL_SIZE];

UINT memscpy
(
  void   *dst,
  UINT   dst_size,
  const  void  *src,
  UINT   src_size
)
{
  UINT  copy_size = (dst_size <= src_size)? dst_size : src_size;
  memcpy(dst, src, copy_size);
  return copy_size;
}

qapi_Status_t malloc_byte_pool_init(void)
{
 	int ret;

	/* Allocate byte_pool_dam (memory heap) */
	ret = txm_module_object_allocate(&byte_malloc_mem_pool, sizeof(TX_BYTE_POOL));
	TX_ASSERT("malloc_byte_pool_init\r\n",ret == TX_SUCCESS);

	/* Create byte_pool_dam */
	ret = tx_byte_pool_create(byte_malloc_mem_pool, "memheap", mem_heap, MALLOC_BYTE_POOL_SIZE);
	TX_ASSERT("tx_byte_pool_create\r\n", ret == TX_SUCCESS);


  return ret;
}

TX_BYTE_POOL *malloc_get_pool(void){
	return byte_malloc_mem_pool;
}

// void *p = malloc(1);
// memset(p,0xaa,1);
// malloc_size_t *header = MALLOC_HEAD(p);
// printf("\r\nAlloc -> p=%p,signature=%x,pref=0x%x,size=%u,%x\r\n",p,header->signature,header->addr,header->size,*(uint32_t*)p);
// p = realloc(NULL,p,8);
// header = MALLOC_HEAD(p);
// printf("Realloc -> p=%p,signature=%x,pref=0x%x,size=%u,%x\r\n",p,header->signature,header->addr,header->size,*(uint32_t*)p);


void *__wrap_malloc(size_t size)
{

	void *ptr = NULL;

	if (0 == size){
		return NULL;
	}

	size *= 2;

#ifdef MALLOC_FREE_INLINE
	uint32_t status = tx_byte_allocate(byte_malloc_mem_pool, (VOID **)&ptr, size, TX_NO_WAIT);
	TX_ERROR(("malloc fail!\r\nMALLOC_BYTE_POOL_SIZE=%u\r\n",MALLOC_BYTE_POOL_SIZE), (status == TX_SUCCESS) , return NULL );
	if(NULL != ptr)  
		memset(ptr, 0, size);
#else
	uint32_t status = tx_byte_allocate(byte_malloc_mem_pool, (VOID **)&ptr, sizeof(malloc_size_t) + size, TX_NO_WAIT);

	TX_ERROR(("malloc fail\r\nMALLOC_BYTE_POOL_SIZE=%u\r\n",MALLOC_BYTE_POOL_SIZE), (status == TX_SUCCESS) , return NULL );

	if(NULL != ptr)  {
		memset(ptr, 0, sizeof(malloc_size_t) + size);
		malloc_size_t *head = ptr;
		head->signature = 0xbeef;
		void *addr = (void*)(ptr + sizeof(malloc_size_t));
		head->addr = (uint32_t)addr;
		head->size = size;
		ptr += sizeof(malloc_size_t);
	}
#endif

	return ptr;
}


void __wrap_free(void *ptr)
{
  	uint32_t status = 0;
  
  	if(NULL == ptr){
    	return;
  	}

#ifdef MALLOC_FREE_INLINE
  	status = tx_byte_release(ptr);  
  	TX_ASSERT("free fail\r\n",status == TX_SUCCESS);
#else
	malloc_size_t *header = MALLOC_HEAD(ptr);
	TX_ASSERT("free header->signature != 0xbeef\r\n",header->signature == 0xbeef);
	TX_ASSERT("free header->addr != ptr\r\n",header->addr == (uint32_t)ptr);
  	status = tx_byte_release(header);  
  	TX_ASSERT("free header->addr != ptr\r\n",status == TX_SUCCESS);
  	header = NULL;
#endif

  	ptr = NULL;
}

void *__wrap_calloc (size_t num, size_t size){
	size *= 2;
	void *ptr = malloc(size*num);
	if(ptr)
		memset(ptr, 0, size*num);
	return ptr;
}

void* __wrap_realloc (void* ptr, size_t size){
    
	void *new = NULL;

#ifndef MALLOC_FREE_INLINE
    if (!ptr) {
		if(size == 0){
			free(ptr);
			ptr = NULL;
			return NULL;
		}
		else{
			new = malloc(size);
			if (!new)
				return NULL;
		}
    } else {
    	
    	if(size == 0){
    		return NULL;
    	}

		new = malloc(size);
		if (!new)
			return NULL;

		malloc_size_t *header = MALLOC_HEAD(ptr);
		TX_ASSERT("realloc header->signature != 0xbeef\r\n",header->signature == 0xbeef);
		TX_ASSERT("realloc header->addr != ptr\r\n",header->addr == (uint32_t)ptr);
		memcpy(new, ptr,header->size); 
		header = MALLOC_HEAD(new);
		TX_ASSERT("realloc headernew->signature != 0xbeef\r\n",header->signature == 0xbeef);
		free(ptr);
		ptr = NULL;
    }
#endif

    return new;

}

/*
* Ignore alignment 
*/
void *memalign(size_t align, size_t len)
{
	void* ptr = malloc(len);
	return ptr;
}


/* automatic undefs */
#undef MALLOC_BYTE_POOL_SIZE
#undef MALLOC_HEAD
#undef TX_MALLOC_MEM_SIZE
/*
 * retarget.c
 *
 *  Created on: 24 Nov.,2019
 *      Author: Nikolas Karakotas
 */
/* #include fin_internal.h -> already included */

#define DEBUG_PORT	QAPI_UART_PORT_002_E

FILE *const stdin;
FILE *const stdout;
FILE *const stderr;

extern int main(void);
extern qapi_Status_t malloc_byte_pool_init(void);
extern TX_BYTE_POOL *malloc_get_pool(void);

static void init_debug(void);

extern int vsnprintf_(char* buffer, size_t count, const char* format, va_list va);

 __attribute__ ((noreturn)) int task_main_entry(void){
	setlocale(LC_ALL, "C");	
	init_debug();
	malloc_byte_pool_init();


	// toggle pseudo STATUS pin
	fin_gpio_pin_config(64,QAPI_GPIO_PULL_UP_E,QAPI_GPIO_12MA_E,QAPI_GPIO_OUTPUT_E);
	fin_gpio_pin_write(64,false);
	fin_sleep(1);
	fin_gpio_pin_write(64,true);

	// Now read fault 
	fin_gpio_pin_release(64);
	fin_gpio_pin_config(64,QAPI_GPIO_PULL_UP_E,QAPI_GPIO_12MA_E,QAPI_GPIO_INPUT_E);
	if(fin_gpio_pin_read(64) == 0){
		puts("[ PROGRAM FAULT ]\r\n");
		exit(1);
	}
	
	main();
	for(;;);
}


static qapi_UART_Handle_t handle = NULL;

TX_MUTEX *out_tx_mutex;
TX_SEMAPHORE *out_tx_done_sem;

#ifndef TX_PRINTF_LEN
#define TX_PRINTF_LEN 512
#elif TX_PRINTF_LEN < 128
#error "TX_PRINTF_LEN < 128"
#endif

#define RECV_QUEUE_MEM_SIZE 512

TX_QUEUE *recv_queue;
uint32_t recv_queue_mem[RECV_QUEUE_MEM_SIZE];



static void rx_queue_task(ULONG param);
TX_THREAD* rx_queue_thread_handle; 
TX_BYTE_POOL *rx_queue_thread_byte_pool;
void *rx_queue_thread_stack;
#define RX_QUEUE_THREAD_STACK_SIZE			512
#define RX_QUEUE_THREAD_BYTE_POOL_SIZE		2*RX_QUEUE_THREAD_STACK_SIZE
char rx_queue_thread_mem[RX_QUEUE_THREAD_BYTE_POOL_SIZE];

#define RX_SIZE RECV_QUEUE_MEM_SIZE/2
volatile uint8_t bytes1[RX_SIZE];
volatile uint8_t bytes2[RX_SIZE];

TX_EVENT_FLAGS_GROUP	*evnt_rx;
const int BYTE_NUM_1 = 1;
const int BYTE_NUM_2 = 2;
#define RX_BUF_SIZE RECV_QUEUE_MEM_SIZE/4
volatile uint8_t rx_buf[RX_BUF_SIZE];
uint32_t rx_buf_head;
uint32_t rx_buf_tail;


static void stdin_rx_cb(uint32_t num_bytes, void *cb_data){

	int num = *(int*)cb_data;

	if(num == BYTE_NUM_1){
		for(int i=0; i < num_bytes; i++){
			uint32_t index = __atomic_fetch_add(&rx_buf_head,1,__ATOMIC_RELAXED);
			if(index+1 >= RX_BUF_SIZE-1){
				__atomic_store_n(&rx_buf_head,0,__ATOMIC_RELAXED);
				index = 0;
			}
			__atomic_store_n (&rx_buf[index], bytes1[i], __ATOMIC_RELAXED);
		}
	}
	else if(num == BYTE_NUM_2){
		for(int i=0; i < num_bytes; i++){
			uint32_t index = __atomic_fetch_add(&rx_buf_head,1,__ATOMIC_RELAXED);
			if(index+1 >= RX_BUF_SIZE-1){
				__atomic_store_n(&rx_buf_head,0,__ATOMIC_RELAXED);
				index = 0;
			}
			__atomic_store_n (&rx_buf[index], bytes2[i], __ATOMIC_RELAXED);
		}
	}


	tx_event_flags_set(evnt_rx,num, TX_OR);


};



static void stdout_tx_cb(uint32_t num_bytes1, void *cb_data){
	tx_semaphore_ceiling_put(out_tx_done_sem,1);
};


static void init_debug(void){

	qapi_UART_Open_Config_t uart_cfg;

	memset (&uart_cfg, 0, sizeof (uart_cfg));


	uart_cfg.baud_Rate			= 115200;
	uart_cfg.enable_Flow_Ctrl	= QAPI_FCTL_OFF_E;
	uart_cfg.bits_Per_Char		= QAPI_UART_8_BITS_PER_CHAR_E;
	uart_cfg.enable_Loopback 	= 0;
	uart_cfg.num_Stop_Bits		= QAPI_UART_1_0_STOP_BITS_E;
	uart_cfg.parity_Mode 		= QAPI_UART_NO_PARITY_E;
	uart_cfg.rx_CB_ISR			= (qapi_UART_Callback_Fn_t)&stdin_rx_cb;
	uart_cfg.tx_CB_ISR			= (qapi_UART_Callback_Fn_t)&stdout_tx_cb;

	if(qapi_UART_Open(&handle, DEBUG_PORT, &uart_cfg) == QAPI_OK && 
		qapi_UART_Power_On(handle) == QAPI_OK){

		txm_module_object_allocate(&recv_queue, sizeof(TX_QUEUE));
		tx_queue_create(recv_queue, "recv_queue_mem",1, recv_queue_mem, RECV_QUEUE_MEM_SIZE);

		txm_module_object_allocate(&out_tx_mutex, sizeof(TX_MUTEX));
		tx_mutex_create(out_tx_mutex,"out_tx_mutex", TX_NO_INHERIT);

		txm_module_object_allocate(&out_tx_done_sem, sizeof(TX_SEMAPHORE));
		tx_semaphore_create(out_tx_done_sem,"out_tx_done_sem", 1);

		txm_module_object_allocate(&evnt_rx, sizeof(TX_EVENT_FLAGS_GROUP));
		tx_event_flags_create(evnt_rx,"evnt_rx");

		txm_module_object_allocate(&rx_queue_thread_byte_pool, sizeof(TX_BYTE_POOL));
		tx_byte_pool_create(rx_queue_thread_byte_pool, "rx_queue_thread_byte_pool", rx_queue_thread_mem, RX_QUEUE_THREAD_BYTE_POOL_SIZE);

		tx_byte_allocate(rx_queue_thread_byte_pool, (VOID **) &rx_queue_thread_stack, RX_QUEUE_THREAD_STACK_SIZE, TX_NO_WAIT);	
		txm_module_object_allocate(&rx_queue_thread_handle, sizeof(TX_THREAD));
		tx_thread_create(rx_queue_thread_handle,
							"rx_queue_task",
						   	rx_queue_task,
						   	(ULONG)0,
						   	rx_queue_thread_stack,
						   	RX_QUEUE_THREAD_STACK_SIZE,
						   	32,
						   	16,
						   	TX_NO_TIME_SLICE,
						   	TX_AUTO_START
		);

		while(qapi_UART_Receive (handle, bytes1, RX_SIZE, &BYTE_NUM_1) != QAPI_OK); // queue as per doc
		while(qapi_UART_Receive (handle, bytes2, RX_SIZE, &BYTE_NUM_2) != QAPI_OK); // queue as per doc


	}
 
}


static void rx_queue_task(ULONG param){

	ULONG actual_events;
	rx_buf_tail = 0;
	rx_buf_head = 0;

	for(;;){


		if(tx_event_flags_get(evnt_rx,BYTE_NUM_1,TX_OR_CLEAR,&actual_events,1) == TX_SUCCESS){
			while(qapi_UART_Receive (handle, bytes1, RX_SIZE, &BYTE_NUM_1) != QAPI_OK); // queue as per doc
		}

		if(tx_event_flags_get(evnt_rx,BYTE_NUM_2,TX_OR_CLEAR,&actual_events,1) == TX_SUCCESS){
			while(qapi_UART_Receive (handle, bytes2, RX_SIZE, &BYTE_NUM_2) != QAPI_OK); // queue as per doc
		}

		uint32_t head = __atomic_load_n(&rx_buf_head,__ATOMIC_RELAXED);
		while(rx_buf_tail != head){
			uint8_t byte = __atomic_load_n(&rx_buf[rx_buf_tail],__ATOMIC_RELAXED);
			rx_buf_tail++;
			if(rx_buf_tail >= RX_BUF_SIZE-1)
				rx_buf_tail = 0;
			tx_queue_send(recv_queue,&byte,TX_WAIT_FOREVER);
		}
		tx_thread_relinquish();

	}

}

int putchar(int character){
	
	if(!handle)
		return 0;

	int c = character; // make a local copy

	if(qapi_UART_Transmit(handle, &c, 1, NULL) == TX_SUCCESS)	// puts removes the new line!
		tx_semaphore_get(out_tx_done_sem,TX_WAIT_FOREVER);
	

	return c;
}

int _putchar(int character){
	return putchar(character);
}

int __wrap_puts(const char *s){

	
	if(!handle)
		return 0;

	tx_mutex_get(out_tx_mutex,TX_WAIT_FOREVER);

	int i = 0;
	int ret = 1;
   	while(s[i]){
	    if( putchar(s[i]) == -1) { 
	        ret = -1;
	    }
	    i++;
    }
	if(putchar('\n') == -1) {

	   ret = -1;
	}

	tx_mutex_put(out_tx_mutex);
   return ret; 

}


/*

*/
int __wrap_printf(const char *format, ...){

	va_list ap;
	int len;

	if(!handle)
		return 0;

	
	char *stdout_buf = malloc(TX_PRINTF_LEN);
	if(!stdout_buf)
		return 0;

	tx_mutex_get(out_tx_mutex,TX_WAIT_FOREVER);

	va_start( ap, format );
	//need to guard when no argumets will call putchar
	len = vsnprintf_( stdout_buf, (size_t)TX_PRINTF_LEN, format, ap ); 
	va_end( ap );

	if(qapi_UART_Transmit(handle, stdout_buf, len, NULL) == TX_SUCCESS)
		tx_semaphore_get(out_tx_done_sem,TX_WAIT_FOREVER);

	free(stdout_buf);

	tx_mutex_put(out_tx_mutex);


	return len;

}

/* STDIN */
char * __wrap_gets ( char * str ){
	return NULL;
}

int __wrap_getchar(void){

	if(!handle)
		return 0;
	
	int c;

	tx_queue_receive(recv_queue, &c, TX_WAIT_FOREVER);


	return c;
}


int __wrap_fprintf(FILE *stream, const char *format, ...){
	puts("__wrap_fprintf: error\r\n");
	return 0;
}

size_t __wrap_write(int fildes, const void *buf, size_t nbytes1){

	// We only have stdout
	if(!handle)
		return 0;

	tx_mutex_get(out_tx_mutex,TX_WAIT_FOREVER);

	if(qapi_UART_Transmit(handle, buf, nbytes1, NULL) == QAPI_OK)	
		tx_semaphore_get(out_tx_done_sem,TX_WAIT_FOREVER);
	else
		nbytes1 = -1;
	
	tx_mutex_put(out_tx_mutex);

	return nbytes1;

}

int __wrap_fflush(FILE *stream){
	if(!handle)	return 0;

	tx_queue_flush(recv_queue);

	return 0;

}


/*

	Tests

	for(uint32_t i = 0; i < 0xFFFF; i++){
		puts("\r\nputs:\r\n");
		puts("The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog");
	}


	for(uint32_t i = 0; i < 0xFFFF; i++){
		puts("\r\nprintf:\r\n");
		printf("%s","The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog \
			The quick brown fox jumps over the lazy dog");
	}

*/

/* automatic undefs */
#undef DEBUG_PORT
#undef RECV_QUEUE_MEM_SIZE
#undef RX_BUF_SIZE
#undef RX_QUEUE_THREAD_BYTE_POOL_SIZE
#undef RX_QUEUE_THREAD_STACK_SIZE
#undef RX_SIZE
#undef TX_PRINTF_LEN
/* #include fin_internal.h -> already included */

/* Must be included here */
#include <sys/stat.h>
#include <dirent.h>

extern int printf(const char *format, ...);

// change to FILE
FILE *fopen(const char *path, const char *mode){

	uint32_t flags;

	if(strcmp(mode,"r") == 0 || strcmp(mode,"rb") == 0)
		flags = QAPI_FS_O_RDONLY_E;
	else if(strcmp(mode,"r+") == 0)
		flags = QAPI_FS_O_RDWR_E;
	else if(strcmp(mode,"w") == 0)
		flags = QAPI_FS_O_WRONLY_E | QAPI_FS_O_TRUNC_E | QAPI_FS_O_CREAT_E;
	else if(strcmp(mode,"w+") == 0)
		flags = QAPI_FS_O_RDWR_E | QAPI_FS_O_TRUNC_E | QAPI_FS_O_CREAT_E;
	else if(strcmp(mode,"a") == 0)
		flags = QAPI_FS_O_WRONLY_E | QAPI_FS_O_APPEND_E | QAPI_FS_O_CREAT_E;
	else if(strcmp(mode,"a+") == 0)
		flags = QAPI_FS_O_RDWR_E | QAPI_FS_O_APPEND_E | QAPI_FS_O_CREAT_E;
	else
		return NULL;

	FILE *fp = malloc(sizeof(int));
	if(qapi_FS_Open ( path, flags, (int*)fp) == QAPI_OK){
		return fp;
	}
	else{
		free(fp);
		return NULL;
	}

}

// change to FILE
int fclose(FILE *fp){
	int *fd = (int*)fp;
	if(fd){
		if(qapi_FS_Close(*fd) == QAPI_OK){
			free(fd);
			return 0;
		}else
			return '\0';
	}else
		return '\0';
}

// change to FILE
int fseek(FILE *fp, long offset, int whence){
	int *fd = (int*)fp;
	int whence_flags;
	qapi_FS_Offset_t actual_offset;

	if(whence == 0)
		whence_flags = QAPI_FS_SEEK_SET_E;
	else if(whence == 1)
		whence_flags = QAPI_FS_SEEK_CUR_E; 
	else if(whence == 2)
		whence_flags = QAPI_FS_SEEK_END_E;

	if(qapi_FS_Seek ( *fd, (qapi_FS_Offset_t)offset, whence_flags, &actual_offset ) == QAPI_OK){
		return 0;
	}else{
		return -1;
	}
}

/*
*	Just return file size as theres no way knowing from current position with QAPI
*/
long ftell(FILE *fp){
	int *fd = (int*)fp;
	struct qapi_FS_Stat_Type_s finfo;
	if(qapi_FS_Stat_With_Handle(*fd,&finfo) == QAPI_OK){
		return finfo.st_size;
	}else{
		return -1;
	}
}

int fstat(int fd, struct stat *statbuf){
	struct qapi_FS_Stat_Type_s st;
	if(qapi_FS_Stat_With_Handle(fd, &st) == QAPI_OK){
		statbuf->st_dev = st.st_dev;
		statbuf->__st_dev_padding = 0;
		statbuf->__st_ino_truncated = 0;
		statbuf->st_mode = st.st_Mode;
		statbuf->st_nlink = st.st_nlink;
		statbuf->st_uid = st.st_uid;
		statbuf->st_gid = st.st_gid;
		statbuf->st_rdev = st.st_rdev;
		statbuf->__st_rdev_padding = 0;
		statbuf->st_size = st.st_size;
		statbuf->st_blksize = st.st_blksize;
		statbuf->st_blocks = st.st_blocks;
		//statbuf->st_atim.tv_sec = st.st_atime;
		//statbuf->st_mtim.tv_sec = st.st_mtime;
		//statbuf->st_ctim.tv_sec = st.ct_time;
		statbuf->st_ino = st.st_ino;
		return 0;
	}
	else{
		return -1;
	}
}
  
int lstat(const char *pathname, struct stat *statbuf){
	struct qapi_FS_Stat_Type_s st;
	if(qapi_FS_Stat (pathname, &st) == QAPI_OK){
		statbuf->st_dev = st.st_dev;
		statbuf->__st_dev_padding = 0;
		statbuf->__st_ino_truncated = 0;
		statbuf->st_mode = st.st_Mode;
		statbuf->st_nlink = st.st_nlink;
		statbuf->st_uid = st.st_uid;
		statbuf->st_gid = st.st_gid;
		statbuf->st_rdev = st.st_rdev;
		statbuf->__st_rdev_padding = 0;
		statbuf->st_size = st.st_size;
		statbuf->st_blksize = st.st_blksize;
		statbuf->st_blocks = st.st_blocks;
		//statbuf->st_atim.tv_sec = st.st_atime;
		//statbuf->st_mtim.tv_sec = st.st_mtime;
		//statbuf->st_ctim.tv_sec = st.ct_time;
		statbuf->st_ino = st.st_ino;
		return 0;
	}
	else{
		return -1;
	}
}

// change to FILE
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp){
	int *fd = (int*)fp;
	struct qapi_FS_Stat_Type_s finfo;
	uint32_t read_bytes = 0;

	if(ptr && fp){	
		if( qapi_FS_Read (*fd, ptr, nmemb, &read_bytes) == QAPI_OK){			
			return read_bytes;
		}else{
			return 0;		
		}
	}else
		return 0;

}


size_t __wrap_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp){
	int *fd = (int*)fp;
	uint32_t written_bytes = -1;
	if(ptr && fp){
		qapi_FS_Write (*fd, ptr,nmemb,&written_bytes);
	}

	return written_bytes;

}



DIR *opendir(const char *name){
 	qapi_FS_Iter_Handle_t dir_handle = malloc(sizeof(qapi_FS_Iter_Handle_t));

	if(qapi_FS_Iter_Open ( name, &dir_handle ) == QAPI_OK){
		return (DIR*)dir_handle;
	}else{
 		return NULL;
	}
 }

 struct dirent *readdir(DIR *dirp){
 	static struct dirent d;
 	struct qapi_FS_Iter_Entry_s iter_entry;
 	qapi_FS_Iter_Handle_t dir_handle;

 	if(dirp){
 		dir_handle = (qapi_FS_Iter_Handle_t)dirp;
 		if(qapi_FS_Iter_Next (dir_handle,&iter_entry) == QAPI_OK){
			if(iter_entry.file_Path[0]){
				strncpy(d.d_name,iter_entry.file_Path,256);
				return &d;
			}else
				return NULL;
 		}else{
 			return NULL;
 		}
 	}else
 		return NULL;

 }

int closedir(DIR *dirp){
	qapi_FS_Iter_Handle_t dir_handle;

	if(dirp){
		dir_handle = (qapi_FS_Iter_Handle_t)dirp;
		if(qapi_FS_Iter_Close (dir_handle) == QAPI_OK){
			free(&dir_handle);
			return 0;
		}
		else{
			return -1;
		}
	}else
		return -1;
}


int rmdir (const char *filename){
	if(filename == NULL) return -1;
	if(qapi_FS_Rm_Dir(filename) == QAPI_OK)
		return 0;
	else
		return -1;
}


int mkdir(const char *pathname, mode_t mode){
	if(pathname == NULL) return -1;
	if(qapi_FS_Mk_Dir (pathname, mode))
		return 0;
	else
		return -1;

}

int unlink (const char *filename){
	if(filename == NULL) return -1;
	if(qapi_FS_Unlink(filename) == QAPI_OK)
		return 0;
	else
		return -1;
}

int truncate(const char *path, off_t length){
	if(path == NULL) return -1;
	if(qapi_FS_Truncate (path, length ) == QAPI_OK)
		return 0;
	else
		return -1;
}

int rename(const char *old, const char *new){
	if(old == NULL && new == NULL) return -1;
	if(qapi_FS_Rename (old,new ) == QAPI_OK)
		return 0;
	else
		return -1;
}

/*

The return value is 0 if the access is permitted, and -1 otherwise. 
(In other words, treated as a predicate function, access returns true if the requested access is denied.)

These macros are defined in the header file unistd.h for use as the how argument to the access function. 
The values are integer constants.

Macro: int R_OK
Flag meaning test for read permission.

Macro: int W_OK
Flag meaning test for write permission.

Macro: int X_OK
Flag meaning test for execute/search permission.

Macro: int F_OK
Flag meaning test for existence of the file.

EACCES The access specified by how is denied.
ENOENT The file doesnâ€™t exist.
EROFS Write permission was requested for a file on a read-only file system.

*/
int access (const char *filename, int how){

	return 0;

}



/*
*
* @author :  Nikolas Karakotas
* @date   :  08/01/2021
*
*/
/* #include fin_internal.h -> already included */

struct adc_map {
	fin_adc_channel_t adc_num;
	qapi_ADC_Handle_t handle;
	qapi_Adc_Input_Properties_Type_t properties;
	const char *channel_name;
};

struct adc_map adc[ADC_MAX_NO] = {
	{ADC0, NULL, {0,0}, ADC_INPUT_ADC0},
	{ADC1, NULL, {0,0}, ADC_INPUT_ADC1}
};



int fin_adc_config(fin_adc_channel_t adc_num){
	if(adc_num >= 0 && adc_num < ADC_MAX_NO){
		if(qapi_ADC_Open(&adc[adc_num].handle, 0) == QAPI_OK){
			return qapi_ADC_Get_Input_Properties(adc[adc_num].handle, 
				adc[adc_num].channel_name, 
				sizeof(adc[adc_num].channel_name), 
				&adc[adc_num].properties);
		}

	}

	return 1;
}

uint32_t fin_adc_read_microvolts(fin_adc_channel_t adc_num){
	qapi_ADC_Read_Result_t res;

	if(adc_num >= 0 && adc_num < ADC_MAX_NO){
		if( qapi_ADC_Read_Channel(adc[adc_num].handle, &adc[adc_num].properties, &res) == QAPI_OK){
			return res.nMicrovolts;
		}
	}

	return -1;

}

uint32_t fin_adc_read_physical(fin_adc_channel_t adc_num){
	qapi_ADC_Read_Result_t res;

	if(adc_num >= 0 && adc_num < ADC_MAX_NO){
		if( qapi_ADC_Read_Channel(adc[adc_num].handle, &adc[adc_num].properties, &res) == QAPI_OK){
			return res.nPhysical;
		}
	}

	return -1;
}

uint32_t fin_adc_read_percent(fin_adc_channel_t adc_num){
	qapi_ADC_Read_Result_t res;

	if(adc_num >= 0 && adc_num < ADC_MAX_NO){
		if( qapi_ADC_Read_Channel(adc[adc_num].handle, &adc[adc_num].properties, &res) == QAPI_OK){
			return res.nPercent;
		}
	}

	return -1;
}

uint32_t fin_adc_read_raw(fin_adc_channel_t adc_num){
	qapi_ADC_Read_Result_t res;

	if(adc_num >= 0 && adc_num < ADC_MAX_NO){
		if( qapi_ADC_Read_Channel(adc[adc_num].handle, &adc[adc_num].properties, &res) == QAPI_OK){
			return res.nCode;
		}
	}

	return -1;
}
/*
 * cli.c
 *
 *  Created on: 30 Nov.,2020
 *      Author: Nikolas Karakotas
 */
/* #include fin_internal.h -> already included */

#undef PATH_MAX
#define PATH_MAX 128

const char *CLI_CMD_HELP = "help";
const char *CLI_CMD_MEMINFO = "meminfo";
const char *CLI_CMD_LS = "ls";
const char *CLI_CMD_CAT = "cat";
const char *CLI_CMD_RM = "rm";
const char *CLI_CMD_MKDIR = "mkdir";
const char *CLI_CMD_TOUCH = "touch";
const char *CLI_CMD_ECHO = "echo";

const char *prompt = "\r\n>> ";

static int cli_cmd_help(fin_cli_t *ctx){

	fin_cli_cmd_t *iter;

	if(ctx){
		iter = ctx->cmds;
		if(iter){
			puts("\r\nFor command help, type COMMAND -h. For example: ls -h.\r\n");
		}

		while(iter){
			puts(iter->name);
			puts(" ");
			iter = iter->next;
		}
	}

	puts("\r\n");

	return 0;

}

extern TX_BYTE_POOL *malloc_get_pool(void);
static int cli_cmd_meminfo(int args, char *argv[]){

	ULONG available;
	ULONG fragments;
	TX_THREAD *first_suspended;
	ULONG suspended_count;
	TX_BYTE_POOL *next_pool;
	UINT status;


	int opt;
	while((opt=getopt(args, argv, ":hm:")) != EOF){
    	switch(opt) {
			case 'm':
					if(strcmp(optarg,"heap") == 0){
					/* Retrieve information about the previously created
					block pool "my_pool." */
					tx_byte_pool_info_get(malloc_get_pool(), 
						"memheap",
						&available, &fragments,&first_suspended, &suspended_count,
						&next_pool);
					printf("Available:\t\t%lu\nFragments:\t\t%lu\nFirst Suspended:\t%p\nSuspended Count:\t%lu\nNext Pool:\t\t%p\n", 
						available,fragments,first_suspended,suspended_count,next_pool);
				}
			break;
			case 'h':
			default:
				puts("Usage: meminfo -m STRING\r\n"
					"STRING:\r\n"
					"\theap\r\n\tDisplay the heap information used by malloc, calloc & realloc."
					);
				break;
    	}
    }

	return 0;

}


static int cli_cmd_ls(int args, char *argv[]){
	char *arg = NULL;
	const char *root= "/";
	char tmp[PATH_MAX];
	DIR * dir;
	struct dirent * d;
	struct stat st;

	if(args == 1){
		/* Always do root when empty */
		if((lstat(root, &st) == 0) && S_ISDIR(st.st_mode)){
			if((dir = opendir(root)) != NULL){
				while((d = readdir(dir)) != NULL){
					printf("%s\r\n",d->d_name);
				}
				closedir(dir);
			}			

		}
	}else if(args == 2){
		arg = argv[1];

		if(!strchr(arg,'-')){
			if((lstat(arg, &st) == 0) && S_ISDIR(st.st_mode)){
				if((dir = opendir(arg)) != NULL){
					while((d = readdir(dir)) != NULL){
						printf("%s\r\n",d->d_name);
					}
					closedir(dir);
				}			

			}
		}else{
			puts("Usage: ls FOLDER\r\n");
		}
	}else
		puts("Usage: ls FOLDER\r\n");

	return 0;

}

static int cli_cmd_cat(int args, char *argv[]){
	FILE * fp;
	char *filename;
	void * buf;
	size_t l, len, rlen=0;
	struct stat st;

	if(args <= 1 || (args == 2 && strcmp(argv[1],"-h") == 0) ){
		// usage
	    puts("Usage: cat <file>\r\n");
	}
	else if(args == 2){
		filename = argv[1];
		if((lstat(filename, &st) == 0) && S_ISREG(st.st_mode)){
			fp = fopen(filename, "r");
			if(fp)
			{
				fseek(fp, 0L, SEEK_END);
				l = ftell(fp);
				fseek(fp, 0L, SEEK_SET);
				if(l > 0)
				{
					buf = malloc(256);
					if(buf)
					{
						for(len = 0; len < l; len += rlen){
							rlen = fread(buf + len, 1, l - len, fp);
							if(rlen == 0) break;
							write(0,buf,rlen);
						}

						free(buf);
					}
				}
				fclose(fp);
			}	

		}
	}

	return 0;

}

static int cli_cmd_rm(int args, char *argv[]){
	int opt;
	while((opt=getopt(args, argv, ":d:")) != -1){
    	switch(opt) {
    		case 'd':
    			rmdir (optarg);
    			break;
    		default:
    			goto usage;
			break;
    	}
    }

    /* Only way to get argumnet without option i.e rm /datatx/app.bin */
    if(args == 2 && optind == 1 && opt == -1 && optarg == NULL && argv[1] != NULL){
    	unlink(argv[1]);
    	return 0;
    }

usage:
	puts("\r\nrm\r\n"
		"Remove files (delete/unlink)\r\n\r\n"
		"Syntax:\r\nrm [options] FILE\r\n\r\n"
		"Options:\r\n\r\n"
		"\t-d\r\n\tRemove a directory\r\n");

	return 0;

}

static int cli_cmd_mkdir(int args, char *argv[]){

    /* Only way to get argumnet without option i.e rm /datatx/app.bin */
    if(args == 2 && optind == 1 && optarg == NULL && argv[args-1] != NULL){
    	mkdir(argv[args-1],QAPI_FS_S_IRUSR_E|QAPI_FS_S_IWUSR_E);
    }else{
		puts("\r\nmkdir\r\n"
		"Create new folder(s), if they do not already exist.\r\n\r\n"
		"Syntax:\r\n\tmkdir FOLDER\r\n\r\n");    	
    }


	return 0;

}

static int cli_cmd_touch(int args, char *argv[]){

    /* Only way to get argumnet without option i.e rm /datatx/app.bin */
    if(args == 2 && optind == 1 && optarg == NULL && argv[args-1] != NULL){
    	FILE * fp = fopen(argv[args-1],"a+");
    	fclose(fp);
    }else{
		puts("\r\ntouch\r\n"
		"Create new file, if it does not already exist.\r\n\r\n"
		"Syntax:\r\n\ttouch FILE\r\n\r\n");    	
    }


	return 0;

}

static int cli_cmd_echo(int args, char *argv[]){
	int opt;
	char *file = NULL;
	char *str = argv[1];
	bool append = false;
	optind = 2;

	while((opt=getopt(args, argv, ":f:a")) != -1){
    	switch(opt) {
    		case 'f':
    			file = strdup(optarg);
    			break;
    		case 'a':
    			append = true;
    			break;
    		default:
    			goto usage;
			break;
    	}
    }

    if(file != NULL && str != NULL){
    	if(append){
    		FILE *fp = fopen(file,"a");
    		if(fp){
    			fwrite(str,1,strlen(str),fp);
    			fclose(fp);
    		}
    	}else{
      		FILE *fp = fopen(file,"w");
    		if(fp){
    			fwrite(str,1,strlen(str),fp);
    			fclose(fp);
    		}  		
    	}

    	free(file);

    	return 0;
    }

usage:
	puts("\r\necho\r\n"
	"Write or append to a file. Default is write.\r\n\r\n"
	"Syntax:\r\necho STRING [options]\r\n\r\n"
	"Options:\r\n\r\n"
	"\t-f\r\n\tFile to write or append to.\r\n"
	"\t-a\r\n\tAppend to a file.\r\n");

	return 0;

}


void fin_cli_free(fin_cli_t *ctx){
	free(ctx->in);
//TODO	free(cli->cmd);
	free(ctx);
}

fin_cli_t *fin_cli_new(void){


	fin_cli_t *ctx = malloc(sizeof(fin_cli_t));
	

	fin_cli_cmd_t *meminfo = malloc(sizeof(fin_cli_cmd_t));
	meminfo->name = (char*)CLI_CMD_MEMINFO;
	meminfo->callback = cli_cmd_meminfo;
	meminfo->next = NULL;

	fin_cli_cmd_t *ls = malloc(sizeof(fin_cli_cmd_t));
	ls->name = (char*)CLI_CMD_LS;
	ls->callback = cli_cmd_ls;
	ls->next = NULL;

	fin_cli_cmd_t *cat = malloc(sizeof(fin_cli_cmd_t));
	cat->name = (char*)CLI_CMD_CAT;
	cat->callback = cli_cmd_cat;
	cat->next = NULL;

	fin_cli_cmd_t *rm = malloc(sizeof(fin_cli_cmd_t));
	rm->name = (char*)CLI_CMD_RM;
	rm->callback = cli_cmd_rm;
	rm->next = NULL;

	fin_cli_cmd_t *mkdir = malloc(sizeof(fin_cli_cmd_t));
	mkdir->name = (char*)CLI_CMD_MKDIR;
	mkdir->callback = cli_cmd_mkdir;
	mkdir->next = NULL;

	fin_cli_cmd_t *touch = malloc(sizeof(fin_cli_cmd_t));
	touch->name = (char*)CLI_CMD_TOUCH;
	touch->callback = cli_cmd_touch;
	touch->next = NULL;

	fin_cli_cmd_t *echo = malloc(sizeof(fin_cli_cmd_t));
	echo->name = (char*)CLI_CMD_ECHO;
	echo->callback = cli_cmd_echo;
	echo->next = NULL;

	touch->next = echo;
	mkdir->next = touch;
	rm->next = mkdir;
	cat->next = rm;
	ls->next = cat;
	meminfo->next = ls; 
	ctx->cmds = meminfo; 

	ctx->in = malloc(STDIO_IN_MAX);
	memset(&ctx->in[0],'\0',STDIO_IN_MAX);
	ctx->head = 0;	
	ctx->tail = 0;
	ctx->count = 0;
	puts(prompt);
	return ctx;
}

int fin_cli_register(fin_cli_t *ctx, const char *name, fin_cli_callback_t func){
	
	fin_cli_cmd_t *iter;

	if(name && func && ctx){

		iter = ctx->cmds;
		while(iter->next != NULL){
			if(strcmp(iter->name,name) == 0 )
				return 1;
			iter = iter->next;
		}

		fin_cli_cmd_t *cmd = malloc(sizeof(fin_cli_cmd_t));
		cmd->name = (char*)name;
		cmd->callback = func;
		cmd->next = NULL;
		
		iter->next = cmd;

		return 0;
	}

	return 1;
}



void fin_cli_input(fin_cli_t *ctx, char c){

	int args = 0;
	char *argv[STDIO_CMD_ARGS_MAX];

	if(c >= 0x20 && c <= 0x7E){ 

		if(ctx->count < STDIO_IN_MAX-1){
			ctx->in[ctx->head++] = c;
			ctx->count++;
		}else{
			ctx->in[STDIO_IN_MAX-1] = '\0';
			ctx->count = STDIO_IN_MAX;
		}

	}else{ // control ascii codes
		if(c != '\n' || c != '\r'){

		}
		else if(c == '\b' || c == 0x08 || c == 0x7F){ // backspace
			if(ctx->count){	
				ctx->head--;			
				ctx->in[ctx->head] = '\0';
				ctx->count--;					
			}
		}else if(c == 0x1b || c == 3){ // CTRL+C

		}

	}


	if((c == '\r' || c == '\n')){

		puts("\r\n");

		if(ctx->count == 0){
			puts(prompt);
			return;
		}

		ctx->in[ctx->count] = '\0';
		//printf("%s,%d,%d\r\n",ctx->in,ctx->count,ctx->head);
		memset(argv,0,STDIO_CMD_ARGS_MAX);
		char *token = strtok(ctx->in, " ");

		while( token != NULL ) {
			argv[args] = strdup(token);
			args++;
		  	token = strtok(NULL, " ");
		}

		if(argv[0] && strcmp(argv[0],"help") == 0){
			cli_cmd_help(ctx);
		}else{

			fin_cli_cmd_t *cmd = ctx->cmds;
			optind = 1;
			opterr = 0;

			while(cmd){
				//printf("cmd->name=%s,argv[0]=%s",cmd->name,argv[0]);
				if(args && argv[0] && strcmp(cmd->name,argv[0]) == 0 )
					cmd->callback(args, argv);
				cmd = cmd->next;

			}

			while(args){
				free(argv[args-1]);
				args--;
			}

		}

		//fflush(stdin);
		memset(ctx->in,'\0',STDIO_IN_MAX);
		ctx->head = 0;
		ctx->tail = 0;
		ctx->count = 0;

		puts(prompt);

	}


}

/* automatic undefs */
#undef PATH_MAX
/*
 * dss.c
 *
 *  Created on: 1 Oct.,2019
 *      Author: Nikolas Karakotas
 */
/* #include fin_internal.h -> already included */


 /* Mask include all DAM signals */
#define DSS_OBJ_SIGNAL_MASK       QAPI_DSS_EVT_NET_IS_CONN_E | \
                                  QAPI_DSS_EVT_NET_NO_NET_E  \

#define DSS_DEVICE_MASK_SET			0xEF
#define DSS_DEVICE_SIGNAL_MASK		(QAPI_DEVICE_INFO_NETWORK_IND_E | DSS_DEVICE_MASK_SET) \
                                  	(QAPI_DEVICE_INFO_SIM_STATE_E | DSS_DEVICE_MASK_SET)
/*
*	TASK
*/
#define THREAD_PRIORITY      180



#define DSS_THREAD_STACK_SIZE			(1024 * 16)
#define DSS_THREAD_BYTE_POOL_SIZE		DSS_THREAD_STACK_SIZE * DSS_CONCURRENT_NUM
char dss_mem[DSS_THREAD_BYTE_POOL_SIZE];


fin_dss_ctx_t *dss_ctx_store[DSS_CONCURRENT_NUM] = {0};

/*
@func
	dss_net_event_cb
@brief
	Initializes the DSS netctrl library for the specified operating mode.
*/
static void dss_net_event_cb(qapi_DSS_Hndl_t hndl, void *user_data,	qapi_DSS_Net_Evt_t evt,	qapi_DSS_Evt_Payload_t *payload_ptr ){
	
	switch (evt)
	{
		case QAPI_DSS_EVT_NET_IS_CONN_E:
		case QAPI_DSS_EVT_NET_NO_NET_E:
		default:	
			if(user_data != NULL)
				tx_event_flags_set(user_data, evt, TX_OR);
			break;
	}
}


static void device_info_cb(qapi_Device_Info_Hndl_t device_info_hndl, const qapi_Device_Info_t *dev_info){

	TX_EVENT_FLAGS_GROUP *evt = NULL;
	for(int i = 0; i < DSS_CONCURRENT_NUM; i++){
		if(dss_ctx_store[i] != NULL){
			if(dss_ctx_store[i]->device_info_handle == device_info_hndl){
				evt = dss_ctx_store[i]->nw_event_handle;
			}
		}
	}

	if(dev_info->id == QAPI_DEVICE_INFO_NETWORK_IND_E)
	{
		switch(dev_info->info_type)
		{
			case QAPI_DEVICE_INFO_TYPE_BOOLEAN_E:
				//unsafe TX_DEBUGF(DSS_DBG,("%c: %d\r\n", dev_info->id, dev_info->u.valuebool));
				if(dev_info->u.valuebool == true){
					if(evt != NULL){
						tx_event_flags_set(evt, QAPI_DEVICE_INFO_NETWORK_IND_E, TX_OR); 
					}
				}
			break;

			case QAPI_DEVICE_INFO_TYPE_INTEGER_E:
				//unsafe TX_DEBUGF(DSS_DBG,("%c: %lld\r\n", dev_info->id, dev_info->u.valueint));
			break;

			case QAPI_DEVICE_INFO_TYPE_BUFFER_E:
				//unsafe TX_DEBUGF(DSS_DBG,("%c: %s\r\n", dev_info->id, dev_info->u.valuebuf.buf));
			default:
				//unsafe TX_DEBUGF(DSS_DBG,("%c: %s\r\n", dev_info->id, "NULL"));
			break;

		}

	}


}


static int dss_show_addr_info(qapi_DSS_Addr_Info_t *info, size_t size){

	TX_ERROR(("dss_show_addr_info: info != NULL\r\n"),(info != NULL), return -1);
	TX_ASSERT("size != 0\r\n",(size != 0));

	char addr[DSS_ADDR_SIZE];

	for (int i = 0; i < size; i++){
		inet_ntop(AF_INET,&info[i].iface_addr_s, addr, DSS_ADDR_SIZE);
		TX_DEBUGF(DSS_DBG,("dss_show_addr_info: IPv4: %s\r\n", addr));
		//memcpy(server_ip, buff, sizeof(server_ip));

		inet_ntop(AF_INET,&info[i].gtwy_addr_s, addr, DSS_ADDR_SIZE);
		TX_DEBUGF(DSS_DBG,("dss_show_addr_info: gateway IPv4: %s\r\n", addr));

		inet_ntop(AF_INET,&info[i].dnsp_addr_s, addr, DSS_ADDR_SIZE);
		TX_DEBUGF(DSS_DBG,("dss_show_addr_info: primary DNS IPv4: %s\r\n", addr));

		inet_ntop(AF_INET,&info[i].dnss_addr_s, addr, DSS_ADDR_SIZE);
		TX_DEBUGF(DSS_DBG,("dss_show_addr_info: second DNS IPv4: %s\r\n", addr));
	}

	return 0;

}

static int dss_get_addr_info(qapi_DSS_Hndl_t handle, qapi_DSS_Addr_Info_t *info, size_t size){

	unsigned int len = 0;	
	qapi_Status_t status;


	TX_ERROR(("dss_get_addr_info: handle != NULL\r\n"),(handle != NULL), return -1);
	TX_ERROR(("dss_get_addr_info: info != NULL\r\n"),(info != NULL), return -1);

	status = qapi_DSS_Get_IP_Addr_Count(handle, &len);
	TX_ERROR(("dss_get_addr_info: get IP address count error\r\n"),(status != QAPI_ERROR), return -1);

	TX_ASSERT("size > len", (size > len));
	status = qapi_DSS_Get_IP_Addr(handle, info, size);
	TX_ERROR(("dss_get_addr_info: get IP address error\r\n"),(status != QAPI_ERROR), return -1);
	if(len>size) len = size;
	return len;
}


static int dss_set_data_parameters(fin_dss_ctx_t *ctx){
    
    qapi_DSS_Call_Param_Value_t param_info;
	qapi_Status_t status;

	
	/* Initial Data Call Parameter */
	TX_ERROR(("dss_set_data_parameters: ctx->dss_handle != NULL\r\n"),(ctx->dss_handle != NULL), return -1);

    /* set data call param */
    param_info.buf_val = NULL;
    param_info.num_val = QAPI_DSS_RADIO_TECH_UNKNOWN;	//Automatic mode(or DSS_RADIO_TECH_LTE)
    TX_DEBUGF(DSS_DBG,("dss: setting tech to Automatic\r\n"));
    status = qapi_DSS_Set_Data_Call_Param(ctx->dss_handle, QAPI_DSS_CALL_INFO_TECH_PREF_E, &param_info);
	TX_ASSERT("status == QAPI_DSS_SUCCESSL\r\n", (status == QAPI_DSS_SUCCESS));

	/* set apn */
	TX_ASSERT("apn != NULL\r\n", (ctx->apn != NULL));
	if(ctx->apn[0] != '\0'){
	    param_info.buf_val = ctx->apn;
	    param_info.num_val = strlen(ctx->apn);
	    TX_DEBUGF(DSS_DBG,("dss: setting APN to '%s'\r\n", ctx->apn));
	    status = qapi_DSS_Set_Data_Call_Param(ctx->dss_handle, QAPI_DSS_CALL_INFO_APN_NAME_E, &param_info);
		TX_ASSERT("status == QAPI_DSS_SUCCESS\r\n", (status == QAPI_DSS_SUCCESS));
	}
	/* set apn username */
	//TX_ASSERT("username != NULL", (ctx->username != NULL));
	if(ctx->username[0] != '\0'){
		param_info.buf_val = ctx->username;
	    param_info.num_val = strlen(ctx->username);
	    TX_DEBUGF(DSS_DBG,("dss: setting APN user name to '%s'\r\n", ctx->username));
	    status = qapi_DSS_Set_Data_Call_Param(ctx->dss_handle, QAPI_DSS_CALL_INFO_USERNAME_E, &param_info);
		TX_ASSERT("status == QAPI_DSS_SUCCESS\r\n", (status == QAPI_DSS_SUCCESS));
	}
	/* set apn password */
	//TX_ASSERT("password != NULL", (ctx->password != NULL));
	if(ctx->password[0] != '\0'){
		param_info.buf_val = ctx->password;
	    param_info.num_val = strlen(ctx->password);
	    TX_DEBUGF(DSS_DBG,("dss: setting APN password to '%s'\r\n", ctx->password));
	    status = qapi_DSS_Set_Data_Call_Param(ctx->dss_handle, QAPI_DSS_CALL_INFO_PASSWORD_E, &param_info);
		TX_ASSERT("status == QAPI_DSS_SUCCESS\r\n", (status == QAPI_DSS_SUCCESS));
	}

	/* set IP version(IPv4 or IPv6) */
    param_info.buf_val = NULL;
    param_info.num_val = QAPI_DSS_IP_VERSION_4;
    TX_DEBUGF(DSS_DBG,("dss: setting family to IPv%d\r\n", param_info.num_val));
    status = qapi_DSS_Set_Data_Call_Param(ctx->dss_handle, QAPI_DSS_CALL_INFO_IP_VERSION_E, &param_info);
	TX_ASSERT("status == QAPI_DSS_SUCCESS\r\n", (status == QAPI_DSS_SUCCESS));

    return 0;

}



static qapi_Status_t dss_net_ctrl_start(fin_dss_ctx_t *ctx)
{
	qapi_Status_t status;
	uint32_t received_sigs = 0;

	TX_ERROR(("dss_net_ctrl_start: ctx->dss_handle == NULL\r\n"),(ctx->dss_handle == NULL), return QAPI_ERROR);
		
	do{

		qapi_DSS_Release(QAPI_DSS_MODE_GENERAL);
		/*
			as per doc: clients are asked to retry this function call repeatedly using a 500 ms timeout interval. 
		*/
		qapi_Timer_Sleep(1000, QAPI_TIMER_UNIT_MSEC, true);

		status = qapi_DSS_Init(QAPI_DSS_MODE_GENERAL);

		TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: dss initialised=%d\r\n",!status));
		
		TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: get service handler...\r\n"));
		
		status = qapi_DSS_Get_Data_Srvc_Hndl(dss_net_event_cb, ctx->dss_event_handle, &ctx->dss_handle);
		TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: dss_handle=%p, status=%d\r\n", ctx->dss_handle, status));
		TX_ASSERT("ctx->dss_handle != NULL\r\n", (ctx->dss_handle != NULL));

	} while(ctx->dss_handle == NULL);


	TX_ERROR(("dss_net_ctrl_start: dss data service obtain handler failed!\r\n"),(status == QAPI_OK), return QAPI_ERROR;);
	TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: dss data service obtain handler completed!\r\n"));

	dss_set_data_parameters(ctx);

	status = qapi_Device_Info_Init_v2(&ctx->device_info_handle);
	TX_ASSERT("status == QAPI_OK\r\n", (status == QAPI_OK));
	status = qapi_Device_Info_Pass_Pool_Ptr(ctx->device_info_handle, ctx->thread_byte_pool);
	TX_ASSERT("status == QAPI_OK\r\n", (status == QAPI_OK));

	
	tx_event_flags_set(ctx->nw_event_handle, 0x0, TX_AND);
	status = qapi_Device_Info_Set_Callback_v2(ctx->device_info_handle,QAPI_DEVICE_INFO_NETWORK_IND_E,device_info_cb);
	TX_ASSERT("status == QAPI_OK\r\n", (status == QAPI_OK));
	/* wait to register on the network - if APN not set i.e left empty it will not register! */
	tx_event_flags_get(ctx->nw_event_handle, QAPI_DEVICE_INFO_NETWORK_IND_E, TX_OR_CLEAR, &received_sigs, TX_WAIT_FOREVER);


#if 0
	qapi_Device_Info_t info;
	memset(&info,0,sizeof(info));

	do{
		status = qapi_Device_Info_Get_v2(ctx->device_info_handle,QAPI_DEVICE_INFO_NETWORK_IND_E,&info);
		TX_ASSERT("status == QAPI_OK\n", (status == QAPI_OK));
		//if(info.u.valuebool == true)
		//	tx_event_flags_set(ctx->nw_event_handle, QAPI_DEVICE_INFO_NETWORK_IND_E, TX_OR); 
	}while(status == QAPI_OK && info.u.valuebool != true);
#endif

	TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: starting data call -> %d\r\n",status));
	status = qapi_DSS_Start_Data_Call(ctx->dss_handle);

	TX_DEBUGF(DSS_DBG,("dss_net_ctrl_start: start data call -> %d\r\n",!status));

	return status;

}


int dss_net_ctrl_stop(qapi_DSS_Hndl_t handle){
	qapi_Status_t stat;

	TX_ERROR(("dss_set_data_parameters: handle != NULL\r\n"),(handle != NULL), return -1);

	stat = qapi_DSS_Stop_Data_Call(handle);
	TX_DEBUGF(DSS_DBG,("dss_net_ctrl_stop: %d\r\n",stat));

	return stat;
}	

void dss_net_no_net(qapi_DSS_Hndl_t hndl)
{
  qapi_DSS_CE_Reason_t ce_reason;
  
  TX_DEBUGF(DSS_DBG,("DAM_APP:Release DSS Handle \r\n"));

  memset(&ce_reason,0,sizeof(qapi_DSS_CE_Reason_t));

  /* Get call end reason */
  if(QAPI_OK == qapi_DSS_Get_Call_End_Reason(hndl, &ce_reason, QAPI_DSS_IP_FAMILY_V4_E)){
    TX_DEBUGF(DSS_DBG,("DAM_APP:Data call released, call end reason:%d \r\n", ce_reason.reason_type));    
  }

  qapi_DSS_Rel_Data_Srvc_Hndl(hndl);

}



static void dss_thread(ULONG param){

	uint32_t received_sigs = 0;
	qapi_Status_t status;
	fin_dss_ctx_t *ctx = (fin_dss_ctx_t*)param;
	qapi_DSS_Addr_Info_t network_info[6];
	char addr[16];
	char gw[16];
	char dnsp[16];
	char dnss[16];

	setlocale(LC_ALL, "C");

	ctx->dss_handle = NULL;
	/* Start data call */
	status = dss_net_ctrl_start(ctx);
	TX_ASSERT("dss_thread: status != QAPI_ERROR", (status != QAPI_ERROR));
	
	for (;;){

		tx_event_flags_get(ctx->dss_event_handle, DSS_OBJ_SIGNAL_MASK, TX_OR_CLEAR, &received_sigs, TX_WAIT_FOREVER);
		TX_DEBUGF(DSS_DBG,("dss_thread: evt [%d]\r\n", received_sigs));
		

		if (received_sigs & QAPI_DSS_EVT_NET_NO_NET_E){
			TX_DEBUGF(DSS_DBG,("dss_thread: QAPI_DSS_EVT_NET_NO_NET_E\r\n"));
			TX_DEBUGF(DSS_DBG,("dss_thread: Stop DNS\r\n"));
			qapi_Net_DNSc_Command(QAPI_NET_DNS_STOP_E);
			dss_net_no_net(ctx->dss_handle);
			if(ctx->notify != NULL){
				ctx->notify->addr[0] = '\0';
				tx_event_flags_set(ctx->notify->evt, QAPI_DSS_EVT_NET_NO_NET_E, TX_OR);
			}

		}
		else if (received_sigs & QAPI_DSS_EVT_NET_IS_CONN_E){
			TX_DEBUGF(DSS_DBG,("dss_thread: QAPI_DSS_EVT_NET_IS_CONN_E\r\n"));
			TX_DEBUGF(DSS_DBG,("dss_thread: Start DNS\r\n"));
			int dns = qapi_Net_DNSc_Command(QAPI_NET_DNS_START_E);
			TX_ASSERT("dss_thread: dns != -1", (status != -1));
			int len = 0;
			if((len = dss_get_addr_info(ctx->dss_handle,&network_info[0],sizeof(network_info))) > 0){
				for(int i=0; i < len; i++){
					const char *ip_p = inet_ntop(AF_INET,&network_info[i].iface_addr_s.addr.v4,addr,sizeof(addr));
					if(ip_p != NULL && ctx->notify != NULL){
						const char *gw_p = inet_ntop(AF_INET,&network_info[i].gtwy_addr_s.addr.v4,gw,sizeof(gw));
						TX_DEBUGF(DSS_DBG,("dss_thread: addr= %s, gw= %s\r\n",ip_p,gw_p));
						
						const char *dnsp_p = inet_ntop(AF_INET,&network_info[i].dnsp_addr_s.addr.v4,dnsp,sizeof(dnsp));
						const char *dnss_p = inet_ntop(AF_INET,&network_info[i].dnss_addr_s.addr.v4,dnss,sizeof(dnss));
						TX_DEBUGF(DSS_DBG,("dss_thread: dnsp= %s, dnss= %s\r\n",dnsp_p,dnss_p));
						TX_DEBUGF(DSS_DBG,("dss_thread: Adding DNS Servers\r\n"));
						qapi_Net_DNSc_Add_Server(dnsp_p, QAPI_NET_DNS_V4_PRIMARY_SERVER_ID);
						qapi_Net_DNSc_Add_Server(dnss_p, QAPI_NET_DNS_V4_SECONDARY_SERVER_ID);
						strncpy(ctx->notify->addr,ip_p,strlen(ip_p));
						tx_event_flags_set(ctx->notify->evt, QAPI_DSS_EVT_NET_IS_CONN_E, TX_OR);
					}

				}
			}

		}else{
			TX_DEBUGF(DSS_DBG,("dss_thread: unknown signal\r\n"));
		}


	}


}



int dss_free(fin_dss_ctx_t *ctx){

	// free all notify events even if they are local.
	return 0;
}

static fin_dss_notify_t dss_notify_local;

int dss_start(fin_dss_ctx_t *ctx){

	TX_ERROR(("dss_start: ctx != NULL\r\n"),(ctx != NULL), return -1);

	TX_DEBUGF(DSS_DBG,("dss_start: notify: %p\r\n",ctx->notify));

	if(ctx->notify == NULL){ // create local notify flag to be used with macros
		ctx->notify = &dss_notify_local;
		memset(ctx->notify->addr,'\0',DSS_ADDR_SIZE);
		txm_module_object_allocate(&ctx->notify->evt, sizeof(TX_EVENT_FLAGS_GROUP));
		tx_event_flags_create(ctx->notify->evt, "dss_local_notify");
		TX_DEBUGF(DSS_DBG,("dss_start: local notify evt: %p\r\n",ctx->notify->evt));
	}

	tx_thread_resume(ctx->thread_handle);

	return 0;

}

int dss_stop(fin_dss_ctx_t *ctx){
	return 0;
}

int dss_restart(fin_dss_ctx_t *ctx){
	return 0;
}

fin_dss_ctx_t *dss_new(const char *apn,const char *password, const char *username){

	int ret;

	fin_dss_ctx_t *ctx = malloc(sizeof(fin_dss_ctx_t));
	memset(ctx,'\0',sizeof(fin_dss_ctx_t));

	if(apn != NULL) strncpy(ctx->apn,apn,QAPI_DSS_CALL_INFO_APN_MAX_LEN-1);
	if(password != NULL) strncpy(ctx->password,password,QAPI_DSS_CALL_INFO_PASSWORD_MAX_LEN-1);
	if(username != NULL) strncpy(ctx->username,username,QAPI_DSS_CALL_INFO_USERNAME_MAX_LEN-1);

	TX_DEBUGF(DSS_DBG,("dss_new: apn = %s, password=%s, username=%s,evt=%p\r\n",ctx->apn,ctx->password,ctx->username,ctx->dss_event_handle));

	/* Create event signal handle and clear signals */
	txm_module_object_allocate(&ctx->dss_event_handle, sizeof(TX_EVENT_FLAGS_GROUP));
	tx_event_flags_create(ctx->dss_event_handle, "dss_event");

	txm_module_object_allocate(&ctx->nw_event_handle, sizeof(TX_EVENT_FLAGS_GROUP));
	tx_event_flags_create(ctx->nw_event_handle, "nw_event_handle");

	txm_module_object_allocate(&ctx->thread_byte_pool, sizeof(TX_BYTE_POOL));
 	tx_byte_pool_create(ctx->thread_byte_pool, "dss_byte_pool", dss_mem, DSS_THREAD_BYTE_POOL_SIZE);

 	/* Start DSS thread, and detect iface status */
	ret = txm_module_object_allocate((VOID *)&ctx->thread_handle, sizeof(TX_THREAD));
	TX_ASSERT("ret == TX_SUCCESS\r\n",(ret == TX_SUCCESS));
	TX_DEBUGF(DSS_DBG,("dss_start: dss_thread_handle = %p\r\n",ctx->thread_handle));
 	
 	tx_byte_allocate(ctx->thread_byte_pool, (VOID **) &ctx->thread_stack, DSS_THREAD_STACK_SIZE, TX_NO_WAIT);		
	txm_module_object_allocate(&ctx->thread_handle, sizeof(TX_THREAD));

	for(int i = 0; i < DSS_CONCURRENT_NUM; i++){
		if(dss_ctx_store[i] == NULL){
			dss_ctx_store[i] = ctx;
			TX_DEBUGF(DSS_DBG,("dss_start: ctx = %p\r\n",dss_ctx_store[i]));
			break;
		}
	}

	ret = tx_thread_create(
		ctx->thread_handle,
		"dss_thread", 
		dss_thread, 
		(ULONG)ctx,
		ctx->thread_stack, 
		DSS_THREAD_STACK_SIZE, 
		THREAD_PRIORITY, 
		THREAD_PRIORITY, 
		TX_NO_TIME_SLICE, 
		TX_DONT_START
	 );

	TX_ASSERT("ret == TX_SUCCESS\r\n",(ret == TX_SUCCESS));
	
	return ctx;

}


/* automatic undefs */
#undef DSS_DEVICE_MASK_SET
#undef DSS_DEVICE_SIGNAL_MASK
#undef DSS_OBJ_SIGNAL_MASK
#undef DSS_THREAD_BYTE_POOL_SIZE
#undef DSS_THREAD_STACK_SIZE
#undef THREAD_PRIORITY
/*
*
* @author :  Nikolas Karakotas
* @date   :  4/1/2021
*
*/
/* #include fin_internal.h -> already included */

typedef struct{
    uint32_t pin_num;   // module pin
    uint32_t pin_soc;   // internal soc pin number
    uint32_t gpio_func;
    const char *int_name;
}GPIO_MAP_TBL;


#define PIN_E_GPIO_MAX 14
const GPIO_MAP_TBL gpio_map_tbl[PIN_E_GPIO_MAX] = {
    /* PIN NUM,       PIN_SOC  GPIO FUNC  INTERRUPT NAME     */
    {  4,             23,      0,         "_int00000004"},
    {  5,             20,      0,         "_int00000005"},
    {  6,             21,      0,         "_int00000006"},
    {  7,             22,      0,         "_int00000007"},
    { 18,             11,      0,         "_int00000018"},  // IO1
    { 19,             10,      0,         "_int00000019"},  // IO2 -> ap ready
    { 22,              9,      0,         "_int00000022"},
    { 23,              8,      0,         "_int00000023"},
    { 26,             15,      0,         "_int00000026"},  // IO3
    { 27,             12,      0,         "_int00000027"},
    { 28,             13,      0,         "_int00000028"},
    { 40,             19,      0,         "_int00000040"},  
    { 41,             18,      0,         "_int00000041"},
    { 64,             07,      0,         "_int00000064"}
};

/* gpio id table - stores */
qapi_GPIO_ID_t gpio_id_tbl[PIN_E_GPIO_MAX];

/* gpio tlmm config table - stores */
qapi_TLMM_Config_t tlmm_config[PIN_E_GPIO_MAX];


qapi_Instance_Handle_t gpio_interrupt_id_tbl[PIN_E_GPIO_MAX];


bool gpio_is_interrupt[PIN_E_GPIO_MAX];


static const struct gpio_list_entry gpio_module_consts[] = {
    { "PIN4",       4 },
    { "PIN5",       5 },
    { "PIN6",       6 },
    { "PIN7",       7 },
    { "PIN18",      18 },
    { "PIN19",      19 },
    { "PIN22",      22 },
    { "PIN23",      23 },
    { "PIN26",      26 },
    { "PIN27",      27 },
    { "PIN28",      28 },
    { "PIN40",      40 },
    { "PIN41",      41 },
    { "PIN64",      64 }
};

static const struct gpio_list_entry gpio_pull_consts[] = {
    { "PullUp",     QAPI_GPIO_PULL_UP_E },
    { "PullDown",   QAPI_GPIO_PULL_DOWN_E },
    { "PullNone",   QAPI_GPIO_NO_PULL_E },
    { "Keeper",  QAPI_GPIO_KEEPER_E }
};

static const struct gpio_list_entry gpio_drive_consts[] = {
    { "Drive2mA",  QAPI_GPIO_2MA_E },
    { "Drive4mA",  QAPI_GPIO_4MA_E },
    { "Drive6mA",  QAPI_GPIO_6MA_E },
    { "Drive8mA",  QAPI_GPIO_8MA_E },
    { "Drive10mA", QAPI_GPIO_10MA_E },
    { "Drive12mA", QAPI_GPIO_12MA_E },
    { "Drive14mA", QAPI_GPIO_14MA_E },
    { "Drive16mA", QAPI_GPIO_16MA_E }
};

static uint32_t get_soc_pin(uint32_t pin){
    uint32_t pin_soc = (uint32_t)-1;

    for(int i=0; i < PIN_E_GPIO_MAX; i++){
        if(gpio_map_tbl[i].pin_num == pin){
            pin_soc = gpio_map_tbl[i].pin_soc;
            break;
        }
    }

   return pin_soc;
}

static int get_soc_pin_index(uint32_t pin){

    for(int i=0; i < PIN_E_GPIO_MAX; i++){
        if(gpio_map_tbl[i].pin_num == pin)
            return i;
    }

   return -1;
}

static qapi_GPIO_ID_t get_gpio_id(uint32_t pin){

    for(uint8_t i=0; i < PIN_E_GPIO_MAX; i++){
        if(gpio_map_tbl[i].pin_num == pin){
            return gpio_id_tbl[i];
        }
    }

    return (uint32_t)-1;
}


static const char *get_pin_name(uint32_t pin){

    for(int i=0; i < sizeof(gpio_module_consts)/sizeof(struct gpio_list_entry); i++){
        if(gpio_module_consts[i].value == pin)
            return gpio_module_consts[i].key;
    }

   return "NULL";
}

static const char *get_pin_drive(uint32_t drive){

    for(int i=0; i < sizeof(gpio_drive_consts)/sizeof(struct gpio_list_entry); i++){
        if(gpio_drive_consts[i].value == drive)
            return gpio_drive_consts[i].key;
    }

   return "NULL";
}

static const char *get_pin_pull(uint32_t pull){

    for(int i=0; i < sizeof(gpio_pull_consts)/sizeof(struct gpio_list_entry); i++){
        if(gpio_pull_consts[i].value == pull)
            return gpio_pull_consts[i].key;
    }

   return "NULL";
}


static qapi_TLMM_Config_t* get_tlmm_config(uint32_t pin){

    for(uint8_t i=0; i < PIN_E_GPIO_MAX; i++){
        if(gpio_map_tbl[i].pin_num == pin){
            return &tlmm_config[i];
        }
    }

    return NULL;
}

static qapi_Instance_Handle_t* get_instance_handle(uint32_t pin){
    for(uint8_t i=0; i < PIN_E_GPIO_MAX; i++){
        if(gpio_map_tbl[i].pin_num == pin){
            return &gpio_interrupt_id_tbl[i];
        }
    }

    return NULL;
}

static qapi_GPIO_Value_t gpio_read( uint32_t pin_soc, qapi_GPIO_ID_t gpio_id) {

    qapi_GPIO_Value_t val;

    qapi_TLMM_Read_Gpio(gpio_id,pin_soc, &val);

    return val;
}

static int gpio_write(uint32_t pin_soc, qapi_GPIO_ID_t gpio_id, bool val) {

    if(val)
        qapi_TLMM_Drive_Gpio(gpio_id, pin_soc, QAPI_GPIO_HIGH_VALUE_E);
    else
        qapi_TLMM_Drive_Gpio(gpio_id, pin_soc, QAPI_GPIO_LOW_VALUE_E);

    return 0;
}

static int gpio_config(uint32_t pin, uint32_t pull, uint32_t dir, qapi_GPIO_Drive_t drive) {

    int index = get_soc_pin_index(pin);
    if(index != -1){

            tlmm_config[index].pin = gpio_map_tbl[index].pin_soc; 
            tlmm_config[index].func = 0; 
            // pin mux value 1
            tlmm_config[index].dir = dir;
            tlmm_config[index].pull =  pull; 
            tlmm_config[index].drive = drive; // drive is for output pins, specify
            gpio_is_interrupt[index] = false;
            // the default here
            qapi_Status_t status = qapi_TLMM_Get_Gpio_ID( &tlmm_config[index], &gpio_id_tbl[index]);
            if (status == QAPI_OK){
                status = qapi_TLMM_Config_Gpio(gpio_id_tbl[index], &tlmm_config[index]);
            }

            if(status != QAPI_OK){
                return 1;
            }else
                return 0;

    }
   
    return 2;  

}


/*      
    QAPI_GPIOINT_TRIGGER_EDGE_FALLING_E;
    QAPI_GPIOINT_TRIGGER_EDGE_RISING_E;
    QAPI_GPIOINT_TRIGGER_LEVEL_HIGH_E;
    QAPI_GPIOINT_TRIGGER_LEVEL_LOW_E;
    QAPI_GPIOINT_TRIGGER_EDGE_DUAL_E;
*/
int fin_gpio_pin_on(uint32_t pin, uint32_t trigger, fin_gpio_interrupt_cb_t interrupt_cb) {

    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){

        qapi_Status_t status = qapi_GPIOINT_Register_Interrupt(
            get_instance_handle(pin),
            get_gpio_id(pin),
            interrupt_cb,
            pin_soc,
            trigger,
            QAPI_GPIOINT_PRIO_LOWEST_E,
            false
            );

        if(status == QAPI_OK){
            return 0;
        }


    }

    return 1; 
}
  
int fin_gpio_pin_trigger(uint32_t pin) {
   
    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){
        return qapi_GPIOINT_Trigger_Interrupt(get_instance_handle(pin), get_gpio_id(pin) );
    }

    return 1;
}


int fin_gpio_pin_disable_irq(uint32_t pin) {
    
    uint32_t pin_soc = get_soc_pin(pin);
    int index = get_soc_pin_index(pin);

    if(pin_soc != (uint32_t)-1UL){
        if(qapi_GPIOINT_Deregister_Interrupt(get_instance_handle(pin), get_gpio_id(pin)) == QAPI_OK){
            gpio_is_interrupt[index] = false;
            return 0;
        }
    }

    return 1;
}

int fin_gpio_pin_enable_irq(uint32_t pin) {

    uint32_t pin_soc = get_soc_pin(pin);
    int index = get_soc_pin_index(pin);

    if(pin_soc != (uint32_t)-1UL){
        if(qapi_GPIOINT_Enable_Interrupt (get_instance_handle(pin), get_gpio_id(pin)) == QAPI_OK){
            gpio_is_interrupt[index] = true;
            return 0;
        }
    }

    return 1;
}


int fin_gpio_pin_config(uint32_t pin, uint32_t pull, uint32_t drive, uint32_t type) {
    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){
        return gpio_config(pin, pull, type, drive);
    }

    return 1;
}

int fin_gpio_pin_output(uint32_t pin, uint32_t pull, uint32_t drive) {

    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){
        if(qapi_TLMM_Release_Gpio_ID(get_tlmm_config(pin), get_gpio_id(pin)) == QAPI_OK){
            return gpio_config(pin_soc, pull, QAPI_GPIO_OUTPUT_E, drive);
        }
    }

    return 1;
}

int fin_gpio_pin_input(uint32_t pin, uint32_t pull, uint32_t drive) {

    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){
        if(qapi_TLMM_Release_Gpio_ID(get_tlmm_config(pin), get_gpio_id(pin)) == QAPI_OK){
           return gpio_config(pin, pull, QAPI_GPIO_INPUT_E, drive);
        }
    }

    return 1;
}

int fin_gpio_pin_release(uint32_t pin) {

    uint32_t pin_soc = get_soc_pin(pin);

    if(pin_soc != (uint32_t)-1UL){
        return qapi_TLMM_Release_Gpio_ID(get_tlmm_config(pin), get_gpio_id(pin));
    }

    return 1; 
}

int fin_gpio_pin_write(uint32_t pin, bool val) {

    uint32_t pin_soc = get_soc_pin(pin);

    if( pin_soc != (uint32_t)-1UL){
        return gpio_write(pin_soc,get_gpio_id(pin), val);
    }

    return 1;
}

int fin_gpio_pin_read(uint32_t pin) {
    
    uint32_t pin_soc = get_soc_pin(pin);

    if( pin_soc != (uint32_t)-1UL){
        return gpio_read(pin_soc,get_gpio_id(pin));
    }

    return 1;
}

void fin_gpio_config_dump(uint32_t pin){
    uint32_t pin_soc = get_soc_pin(pin);
    int index = get_soc_pin_index(pin);

    if( pin_soc != (uint32_t)-1UL && index != -1){

        printf("Pin: %u\r\n"
            "Pin Soc: %u\r\n"
            "Pin Name: %s\r\n"
            "Direction: %s\r\n"
            "Function: %u\r\n"
            "Pull: %s\r\n"
            "Drive: %s\r\n"
            "Irq Enabled: %s\r\n",
            pin,
            pin_soc,
            get_pin_name(pin),
            (tlmm_config[index].dir == QAPI_GPIO_INPUT_E ? "input" : "output"),
            tlmm_config[index].func, 
            get_pin_pull(tlmm_config[index].pull),
            get_pin_drive(tlmm_config[index].drive),
            gpio_is_interrupt[index] == 0 ? "no" : "yes"
            );
    }else{
        puts("NULL\r\n");
    }
}


/* automatic undefs */
#undef PIN_E_GPIO_MAX
/* #include fin_internal.h -> already included */

char http_client_mem[HTTP_CLIENT_BYTE_POOL_SIZE];

static void http_client_cb(void* arg, int state, void* http_resp){
    
    fin_http_client_ctx_t *ctx = (fin_http_client_ctx_t*)arg;

    qapi_Net_HTTPc_Response_t * resp = (qapi_Net_HTTPc_Response_t *)http_resp;

	//unsafe TX_DEBUGF(HTTP_CLIENT_DBG,("%p,state=%d,len=%u,code=%u\r\n",arg,state,resp->length,resp->resp_Code));

    http_client_entry_t *entry = malloc(sizeof(http_client_entry_t));
    if(entry)
    	entry->code = resp->resp_Code;

    if( state == QAPI_NET_HTTPC_RX_FINISHED || state == QAPI_NET_HTTPC_RX_MORE_DATA){
    	
    	if(entry){
    		entry->data = malloc(resp->length+1); // add null
    		if(entry->data){
    			memcpy(entry->data,resp->data,resp->length);
    			entry->data[resp->length] = '\0';
    			entry->data_len = resp->length;
    		}

    		entry->header = malloc(resp->rsp_hdr_len+1); // add null
			if(entry->header){
				memcpy(entry->header,resp->rsp_hdr,resp->rsp_hdr_len);
				entry->header[resp->rsp_hdr_len] = '\0';
    			entry->header_len = resp->rsp_hdr_len;
			}

			list_add(&entry->head,&ctx->list);
    		
    	}
    	if(state == QAPI_NET_HTTPC_RX_FINISHED)
    		tx_event_flags_set(ctx->evt, HTTP_CLIENT_EVT_FINISHED, TX_OR);
    }else if(state == QAPI_NET_HTTPC_RX_ERROR_CONNECTION_CLOSED){
    	tx_event_flags_set(ctx->evt, HTTP_CLIENT_EVT_ERROR_CONNECTION_CLOSED, TX_OR);
    }else if(state == QAPI_NET_HTTPC_RX_ERROR_CLIENT_TIMEOUT){
    	tx_event_flags_set(ctx->evt, HTTP_CLIENT_EVT_ERROR_CLIENT_TIMEOUT, TX_OR);
    }

 
}

#define http_client_start() qapi_Net_HTTPc_Start()
#define http_client_stop() qapi_Net_HTTPc_Stop() 

#define htpp_client_set_default_config(ctx) \
do{ \
	memset(&ctx->so_linger, 0x00, sizeof(struct linger)); \
	ctx->so_linger.l_onoff = 1; \
	ctx->httpc_cfg = malloc(sizeof(qapi_Net_HTTPc_Config_t)); \
	ctx->httpc_cfg->sock_options = malloc(sizeof(qapi_Net_HTTPc_Sock_Opts_t)); \
    ctx->httpc_cfg->addr_type = AF_INET; \
	ctx->httpc_cfg->sock_options_cnt = 0; \
	ctx->httpc_cfg->sock_options->opt_name = SO_LINGER; \
	ctx->httpc_cfg->sock_options->opt_len = sizeof(struct linger); \
	ctx->httpc_cfg->sock_options->opt_value = &ctx->so_linger; \
	ctx->httpc_cfg->max_send_chunk = 1024; \
	ctx->httpc_cfg->max_send_chunk_delay_ms = 10; \
	ctx->httpc_cfg->max_send_chunk_retries = 5; \
	ctx->httpc_cfg->max_conn_poll_cnt = 10; \
	ctx->httpc_cfg->max_conn_poll_interval_ms = 500; \
	if(ctx->ssl.ctx != 0 &ctx->ssl.ctx != QAPI_NET_SSL_INVALID_HANDLE) \
		qapi_Net_HTTPc_Configure(ctx->handle, ctx->httpc_cfg); \
}while(0)

#define htpp_client_config_free(ctx) \
do{ free(ctx->httpc_cfg); free(ctx->httpc_cfg->sock_options); }while(0)

#define http_client_session_connect(ctx,url,port) \
qapi_Net_HTTPc_Connect(ctx->handle,url, port)

#define http_client_session_disconnect(ctx) \
do{ \
	if(qapi_Net_HTTPc_Disconnect(ctx->handle) == QAPI_OK){  \
		TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session_disconnect\r\n")); \
	} \
}while(0)

#define http_client_session_free(ctx) \
do{ \
	TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session_free\r\n")); \
	qapi_Net_HTTPc_Free_sess(ctx->byte_pool); \
}while(0)


static void *http_client_new_session(fin_http_client_ctx_t *ctx, uint32_t t, uint32_t blen, uint32_t hlen){
	qapi_HTTPc_CB_t cb;
	int ret;
	cb = (ctx->user_callback != NULL) ? ctx->user_callback : http_client_cb;
	ctx->handle = qapi_Net_HTTPc_New_sess(t, ctx->ssl.ctx, cb, ctx, blen, hlen); 
	TX_ASSERT("http_client: session ctx->handle != NULL\r\n",(ctx->handle != NULL)); 
	TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session: setting up...\r\n"));
	if(ctx->handle){ 
		htpp_client_set_default_config(ctx);
		if(ctx->ssl.ctx != QAPI_NET_SSL_INVALID_HANDLE){
			if((ret = qapi_Net_HTTPc_Configure_SSL(ctx->handle, &ctx->ssl.config)) == QAPI_OK)
				TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session: ssl configured\r\n"));
			else
				TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session: ssl not configured=%d\r\n",ret));
		}
		qapi_Net_HTTPc_Pass_Pool_Ptr(ctx->handle, ctx->byte_pool);
		TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session: setup\r\n"));
	} 
	return ctx->handle; 
}

#define http_client_ssl_free(ctx) \
do{	\
	qapi_Net_SSL_Obj_Free(ctx->ssl.ctx); \
	ctx->ssl.ctx = 0; \
}while(0)

#define http_client_set_sni(ctx, domain) \
do{ \
	if(ctx && domain){ \
		ctx->ssl.config.sni_Name=(char*)domain; \
		ctx->ssl.config.sni_Name_Size=strlen(domain); \
	} \
} while (0)

static int http_client_ssl_new(fin_http_client_ctx_t *ctx){


	ctx->ssl.role = QAPI_NET_SSL_CLIENT_E;
	ctx->ssl.ctx = qapi_Net_SSL_Obj_New(QAPI_NET_SSL_CLIENT_E);
	TX_ASSERT("http_client_ssl_new: ctx->ssl.ctx != QAPI_NET_SSL_INVALID_HANDLE\r\n",(ctx->ssl.ctx != QAPI_NET_SSL_INVALID_HANDLE)); 

	ctx->ssl.config.cipher[0] = QAPI_NET_TLS_RSA_WITH_AES_128_CBC_SHA;
	ctx->ssl.config.cipher[1] = QAPI_NET_TLS_RSA_WITH_AES_256_CBC_SHA;
	ctx->ssl.config.cipher[2] = QAPI_NET_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
	ctx->ssl.config.cipher[3] = QAPI_NET_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
	ctx->ssl.config.cipher[4] = QAPI_NET_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
	ctx->ssl.config.cipher[0] = QAPI_NET_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
	ctx->ssl.config.cipher[6] = QAPI_NET_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
	ctx->ssl.config.cipher[7] = QAPI_NET_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
	
	ctx->ssl.config.max_Frag_Len = 512;
	ctx->ssl.config.max_Frag_Len_Neg_Disable = 1;
	ctx->ssl.config.protocol = QAPI_NET_SSL_PROTOCOL_TLS_1_2;
	ctx->ssl.config.verify.domain = 0;
	ctx->ssl.config.verify.send_Alert = 0;
	ctx->ssl.config.verify.time_Validity = 0;	/* Don't check certification expiration */
	//strncpy(ctx->ssl.config.verify.match_Name,"api.algoexplorer.io",strlen("api.algoexplorer.io"));
	return 0;
}


fin_http_client_ctx_t *fin_htpp_client_new(void){
	http_client_start();
	fin_http_client_ctx_t *ctx = malloc(sizeof(fin_http_client_ctx_t));
	ctx->timeout = HTTP_CLIENT_TIMEOUT;
	ctx->ssl.ctx = 0;
	memset(&ctx->ssl, 0, sizeof(http_client_ssl_t));	
	ctx->use_https = false;
	txm_module_object_allocate(&ctx->byte_pool, sizeof(TX_BYTE_POOL)); 
	tx_byte_pool_create(ctx->byte_pool, "http_client_mem", http_client_mem, sizeof(http_client_mem)); 
	txm_module_object_allocate(&ctx->evt, sizeof(TX_EVENT_FLAGS_GROUP));
	tx_event_flags_create(ctx->evt, "http_client evt");
	init_list_head(&ctx->list);
	return ctx;
}

int fin_htpp_client_free(fin_http_client_ctx_t *ctx){
	tx_byte_pool_delete(ctx->byte_pool);
	txm_module_object_deallocate(&ctx->byte_pool);
	tx_event_flags_delete(ctx->evt);
	txm_module_object_deallocate(&ctx->evt);
	free(ctx);
	http_client_stop();
	return 0;
}


int fin_htpp_client_set_header(fin_http_client_ctx_t *ctx, const char *key, const char *value){
	if(ctx && ctx->handle)
		return qapi_Net_HTTPc_Add_Header_Field(ctx->handle, key, value);
	else
		return 1;
}

int fin_htpp_client_set_parameter(fin_http_client_ctx_t *ctx, const char *key, const char *value){
	if(ctx && ctx->handle)
		return qapi_Net_HTTPc_Set_Param(ctx->handle, key, value);
	else
		return 1;
}

int fin_htpp_client_set_body(fin_http_client_ctx_t *ctx, const char *body, uint32_t len){
	if(ctx && ctx->handle)
		return qapi_Net_HTTPc_Set_Body(ctx->handle, body, len);
	else
		return 1;

}



int fin_htpp_client_get(fin_http_client_ctx_t *ctx, const char *host, int port, const char *path){

	int err = 1;
	char url[128];
	const char *p_host = host;
	int ret;

	if(ctx == NULL)
		return -1;

	if(strstr(host,"https://") != NULL){
		snprintf(url,sizeof(url),"%s/%s",host,path);
		http_client_ssl_new(ctx);
		ctx->use_https = true;
	}else{
		snprintf(url,sizeof(url),"%s/%s",host,path);
		ctx->use_https = false;
	}


	if((p_host = strstr(host,"//")) != NULL)
		p_host += 2;

	if(ctx->use_https)
		http_client_set_sni(ctx,p_host);

	TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_get: host:%s, %s:%u \r\n",p_host,url,port));

	if(http_client_new_session(ctx,HTTP_CLIENT_TIMEOUT,HTTP_CLIENT_BODY_LEN_MAX,HTTP_CLIENT_HEADER_LEN_MAX) != NULL){
		if((ret = http_client_session_connect(ctx,p_host,port)) == QAPI_OK){
			TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session_connected\r\n")); 
			if((ret = qapi_Net_HTTPc_Request(ctx->handle,QAPI_NET_HTTP_CLIENT_GET_E, url)) == QAPI_OK){
				TX_DEBUGF(HTTP_CLIENT_DBG,("http client request successful\r\n")); 
				// wait
				uint32_t signal = 0; 
				tx_event_flags_get(ctx->evt, HTTP_CLIENT_EVT_FINISHED | HTTP_CLIENT_EVT_ERROR_CONNECTION_CLOSED, TX_OR_CLEAR, &signal, ctx->timeout);
				TX_DEBUGF(HTTP_CLIENT_DBG,("http client evt:%d\r\n",signal)); 
				http_client_session_disconnect(ctx);

				err = 0;
			}

		}
		TX_DEBUGF(HTTP_CLIENT_DBG,("http_client_session_connect: ret=%d\r\n",ret)); 
		
		if(ctx->use_https)
			http_client_ssl_free(ctx);

		htpp_client_config_free(ctx);
		http_client_session_free(ctx);
	}

	qapi_Net_HTTPc_Clear_Header(ctx->handle);	
	return err;	

}



/* automatic undefs */
#undef htpp_client_config_free
#undef htpp_client_set_default_config
#undef http_client_session_connect
#undef http_client_session_disconnect
#undef http_client_session_free
#undef http_client_set_sni
#undef http_client_ssl_free
#undef http_client_start
#undef http_client_stop
/*
*
* @author :  Nikolas Karakotas
* @date   :  01/02/2021
*
*/


/* #include fin_internal.h -> already included */


void fin_hwrandombytes(uint8_t *buf, uint64_t size ){

	qapi_QT_Random_Data_Get(size,buf);

}
/* #include fin_internal.h -> already included */



typedef struct {
    const fin_i2c_num_t num;
    const uint32_t instance;
    void *handle;
    uint32_t transferred1;
	uint32_t transferred2;
	uint32_t frequency;
	volatile uint32_t lock;
	bool configured;
}i2c_map_tbl_t;

i2c_map_tbl_t i2c_map_tbl[I2C_MAX_NO] = {
    {  	I2C1,  QAPI_I2CM_INSTANCE_004_E,      	NULL,	0,	0, I2C_DEFAULT_FREQ, 0, 0},
    {  	I2C2,  QAPI_I2CM_INSTANCE_005_E,      	NULL,	0,	0, I2C_DEFAULT_FREQ, 0, 0}
};

static const struct i2c_list_entry i2c_module_consts[] = {
    { "I2C1",       I2C1 },
    { "I2C2",       I2C2 },
    { NULL, 0 }
};


static void invoke_i2c_callback_1(const uint32 status, void *param){
	// param not passed correctly...
	uint32_t expected;
	//if(i2c_num >= 0 && i2c_num < I2C_MAX_NO){
		while(__atomic_compare_exchange_n(
					&i2c_map_tbl[I2C1].lock,
					&expected,
					0,
					false,
					__ATOMIC_SEQ_CST,
					__ATOMIC_SEQ_CST) != 1);
	//}
}


static void invoke_i2c_callback_2(const uint32 status, void *param){
	// param not passed correctly...
	//int i2c_num = *(int*)param;
	uint32_t expected;
	//if(i2c_num >= 0 && i2c_num < I2C_MAX_NO){
		while(__atomic_compare_exchange_n(
					&i2c_map_tbl[I2C2].lock,
					&expected,
					0,
					false,
					__ATOMIC_SEQ_CST,
					__ATOMIC_SEQ_CST) != 1);
	//}
}


int fin_i2c_transfer(fin_i2c_num_t i2c_num, uint16_t addr, uint8_t *tx_data, size_t tx_data_size, 
	uint8_t *rx_data, size_t rx_data_size, uint32_t delay_us){


	if((i2c_num >= 0 && i2c_num < I2C_MAX_NO) && i2c_map_tbl[i2c_num].configured){

	    qapi_I2CM_Config_t config;
	   	qapi_I2CM_Descriptor_t desc[2];

	   	// Configure the bus speed and slave address
		config.bus_Frequency_KHz = i2c_map_tbl[i2c_num].frequency; 
		config.slave_Address     = addr;
		config.SMBUS_Mode        = 0;
		config.slave_Max_Clock_Stretch_Us = 100000;
		config.core_Configuration1 = 0;
		config.core_Configuration2 = 0;

		uint8_t to_send = 0;

		if(tx_data != NULL){
			desc[0].buffer      = tx_data;
			desc[0].length      = tx_data_size;
			desc[0].transferred = (uint32_t)&i2c_map_tbl[i2c_num].transferred1;
			desc[0].flags       = QAPI_I2C_FLAG_START | QAPI_I2C_FLAG_WRITE | QAPI_I2C_FLAG_STOP;
			to_send++;
 		}

		if(rx_data != NULL){
			desc[1].buffer      = rx_data;
			desc[1].length      = rx_data_size;
			desc[1].transferred = (uint32_t)&i2c_map_tbl[i2c_num].transferred2;  
			desc[1].flags       = QAPI_I2C_FLAG_START | QAPI_I2C_FLAG_READ  | QAPI_I2C_FLAG_STOP;
			to_send++;
		}
		
		if(i2c_num == I2C1){
			if(__atomic_load_n(&i2c_map_tbl[i2c_num].lock,__ATOMIC_SEQ_CST) == 0){
				if(qapi_I2CM_Transfer(i2c_map_tbl[i2c_num].handle, &config, &desc[0], to_send, 
					invoke_i2c_callback_1, &i2c_map_tbl[i2c_num].num, delay_us) == QAPI_OK){
					uint32_t expected;
					while(__atomic_compare_exchange_n(
						&i2c_map_tbl[i2c_num].lock,
						&expected,
						1,
						false,
						__ATOMIC_SEQ_CST,
						__ATOMIC_SEQ_CST) != 1)
						;

					return 0;
				}else
					return 2;

			}else
				return 3;

		}else if(i2c_num == I2C2){
			if(__atomic_load_n(&i2c_map_tbl[i2c_num].lock,__ATOMIC_SEQ_CST) == 0){
				if(qapi_I2CM_Transfer(i2c_map_tbl[i2c_num].handle, &config, &desc[0], to_send, 
					invoke_i2c_callback_2, &i2c_map_tbl[i2c_num].num, delay_us) == QAPI_OK){
					uint32_t expected;
					while(__atomic_compare_exchange_n(
						&i2c_map_tbl[i2c_num].lock,
						&expected,
						1,
						false,
						__ATOMIC_SEQ_CST,
						__ATOMIC_SEQ_CST) != 1);

					return 0;
				}else
					return 2;

			}else
				return 3;
		}

	}

	return 1;
}



int fin_i2c_start(fin_i2c_num_t i2c_num){

	qapi_I2CM_Config_t config;
	qapi_I2CM_Descriptor_t desc[1];

	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO && i2c_map_tbl[i2c_num].configured){

	   	// Configure the bus speed and slave address
		config.bus_Frequency_KHz = i2c_map_tbl[i2c_num].frequency; 
		config.slave_Address     = 0;
		config.SMBUS_Mode        = 0;
		config.slave_Max_Clock_Stretch_Us = 100000;
		config.core_Configuration1 = 0;
		config.core_Configuration2 = 0;

		desc[0].buffer      = NULL;
		desc[0].length      = 0;
		desc[0].transferred = 0; // (uint32)&transferred1;
		desc[0].flags       = QAPI_I2C_FLAG_START;

		return qapi_I2CM_Transfer(i2c_map_tbl[i2c_num].handle, &config, &desc[0], 1, NULL, &i2c_map_tbl[i2c_num].num, 0);

	}

	return 1;
}

int fin_i2c_stop(fin_i2c_num_t i2c_num){

    qapi_I2CM_Config_t config;
   	qapi_I2CM_Descriptor_t desc[2];

	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO && i2c_map_tbl[i2c_num].configured){

	   	// Configure the bus speed and slave address
		config.bus_Frequency_KHz = i2c_map_tbl[i2c_num].frequency; 
		config.slave_Address     = 0;
		config.SMBUS_Mode        = 0;
		config.slave_Max_Clock_Stretch_Us = 100000;
		config.core_Configuration1 = 0;
		config.core_Configuration2 = 0;

		desc[0].buffer      = NULL;
		desc[0].length      = 0;
		desc[0].transferred = 0; // (uint32)&transferred1;
		desc[0].flags       = QAPI_I2C_FLAG_STOP;

		return qapi_I2CM_Transfer(i2c_map_tbl[i2c_num].handle, &config, &desc[0], 1, NULL, &i2c_map_tbl[i2c_num].num, 0);
	
	}

	return 1;
}


int fin_i2c_config(fin_i2c_num_t i2c_num){

	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO){
		if(qapi_I2CM_Open(i2c_map_tbl[i2c_num].instance, &i2c_map_tbl[i2c_num].handle) == QAPI_OK 
			&& !i2c_map_tbl[i2c_num].lock){
	   		if(qapi_I2CM_Power_On(i2c_map_tbl[i2c_num].handle) == QAPI_OK){
	   			i2c_map_tbl[i2c_num].configured = true;
	   			return 0;
	   		}
	    }
	}

	return 1;
}

int fin_i2c_deconfig(fin_i2c_num_t i2c_num){
	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO){
		if(qapi_I2CM_Close (i2c_map_tbl[i2c_num].handle) == QAPI_OK){
			if(qapi_I2CM_Power_Off(i2c_map_tbl[i2c_num].handle) == QAPI_OK){
				i2c_map_tbl[i2c_num].configured = false;
				return 0;
			}
		}
	}

	return 1;
}

int fin_i2c_set_frequency(fin_i2c_num_t i2c_num, uint32_t frequency){
	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO){
		i2c_map_tbl[i2c_num].frequency = frequency;
		return 0;
	}
	return 1;
}

int fin_i2c_power_down(fin_i2c_num_t i2c_num){
	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO)
		return qapi_I2CM_Power_Off(i2c_map_tbl[i2c_num].handle);

	return 1;
}

int fin_i2c_power_up(fin_i2c_num_t i2c_num){
	if(i2c_num >= 0 && i2c_num < I2C_MAX_NO)
		return qapi_I2CM_Power_On(i2c_map_tbl[i2c_num].handle);
	
	return 1;
}
/* #include fin_internal.h -> already included */


const char *fin_resolve_host_itf(const char *domain, const char *itf, char *buf, size_t buf_len){

	struct ip46addr ipaddr;
	int ret;
	if (!qapi_Net_DNSc_Is_Started())
	{
		printf("DNS client is not started yet.\n");
		return NULL;
	}
	memset(&ipaddr, 0, sizeof(ipaddr));
	/*If ipaddr.type = AF_INET, resolve to an IPv4 address
	If ipaddr.type = AF_INET6, resolve to an IPv6 address */
	ipaddr.type = AF_INET;
	if(buf){
		memset(buf,0,buf_len);
		if(qapi_Net_DNSc_Reshost_on_iface(domain, &ipaddr, itf) == QAPI_OK){
			return inet_ntop(AF_INET, &ipaddr.a, buf, buf_len);
		}
	}

	return NULL;

}
/*
*
* @author :  Nikolas Karakotas
* @date   :  16/01/2021
*
*/
/* #include fin_internal.h -> already included */


typedef struct {
    const fin_spi_num_t	num;
    const uint32_t 		instance;
    void*				handle;
    spi_cs_mode_t		cs_mode;
    spi_cs_polarity_t 	cs_polarity;
	spi_endian_t		endian;
	spi_mode_t 			mode;
	spi_bits_per_word_t	bpw;
	uint32_t 			frequency;
	uint8_t				cs_delay;
	uint8_t				inter_word_delay;
	uint8_t				slaves;					// max 7
	bool 				loopback;
	volatile uint32_t   status;
	volatile uint32_t 	lock;
	volatile uint32_t 	signal;
	bool				configured;
}spi_map_tbl_t;

spi_map_tbl_t spi_map_tbl[SPI_MAX_NO] = {
    {  	SPI1,  QAPI_SPIM_INSTANCE_6_E,	NULL,	SPI_CS_KEEP_ASSERTED,	SPI_CS_ACTIVE_LOW, SPI_BYTE_ORDER_LITTLE_ENDIAN,	SPI_MODE_0,	SPI_BPW_8,	SPI_DEFAULT_FREQ, 0, 0, 0, false, 0, 0, 0, 0},
    {  	SPI2,  QAPI_SPIM_INSTANCE_5_E,  NULL,	SPI_CS_KEEP_ASSERTED,	SPI_CS_ACTIVE_LOW, SPI_BYTE_ORDER_LITTLE_ENDIAN,	SPI_MODE_0, SPI_BPW_8,	SPI_DEFAULT_FREQ, 0, 0, 0, false, 0, 0, 0, 0}
};

static const struct spi_list_entry spi_module_consts[] = {
    { "SPI1",       SPI1 },
    { "SPI2",       SPI2 },
    { NULL, 0 }
};


static void fin_spi_cb_func(uint32 status, void *cb_para){

	int spi_num = *((int*)cb_para);
	uint32_t expected;

	if(spi_num >= SPI1 && spi_num <=SPI2 ){

		spi_map_tbl[spi_num].status = status; // no need for atomic
	    
	    if (QAPI_SPI_COMPLETE == status){
	    	while(__atomic_compare_exchange_n(
						&spi_map_tbl[spi_num].signal,
						&expected,
						1,
						false,
						__ATOMIC_SEQ_CST,
						__ATOMIC_SEQ_CST) != 1);
	    	

	    }else if (QAPI_SPI_QUEUED == status || QAPI_SPI_IN_PROGRESS == status){

	    }else{
	    	while(__atomic_compare_exchange_n(
						&spi_map_tbl[spi_num].signal,
						&expected,
						1,
						false,
						__ATOMIC_SEQ_CST,
						__ATOMIC_SEQ_CST) != 1);
	    }
	}

}


int fin_spi_power_down(fin_spi_num_t spi_num){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		return qapi_SPIM_Power_Off(spi_map_tbl[spi_num].handle);
	}

	return 1;
}

int fin_spi_power_up(fin_spi_num_t spi_num){

	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		return qapi_SPIM_Power_On(spi_map_tbl[spi_num].handle);
	}

	return 1;
}

int fin_spi_config(fin_spi_num_t spi_num){

	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		if(qapi_SPIM_Open(spi_map_tbl[spi_num].instance, &spi_map_tbl[spi_num].handle) == QAPI_OK 
			&& !spi_map_tbl[spi_num].lock){
			if(qapi_SPIM_Power_On(spi_map_tbl[spi_num].handle) == QAPI_OK){
				spi_map_tbl[spi_num].configured = true;
				return 0;
			}
		}
	}

	return 1;

}

int fin_spi_deconfig(fin_spi_num_t spi_num){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		if(qapi_SPIM_Close(spi_map_tbl[spi_num].handle) == QAPI_OK){
			if(qapi_SPIM_Power_Off(spi_map_tbl[spi_num].handle) == QAPI_OK){
				spi_map_tbl[spi_num].configured = false;
				return 0;
			}
		}
	}

	return 1;
}

int fin_spi_set_frequency(fin_spi_num_t spi_num, uint32_t frequency){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].frequency = frequency;
		return 0;
	}

	return 1;
}

int fin_spi_set_endianess(fin_spi_num_t spi_num, spi_endian_t endian){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].endian = endian;
		return 0;
	}

	return 1;
}

int fin_spi_set_bit_per_word(fin_spi_num_t spi_num, spi_bits_per_word_t bpw){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].bpw = bpw;
		return 0;
	}

	return 1;
}

int fin_spi_set_mode(fin_spi_num_t spi_num, spi_mode_t mode){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].mode = mode;
		return 0;
	}

	return 1;
}

int fin_spi_set_inter_word_delay(fin_spi_num_t spi_num, uint8_t delay){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].inter_word_delay = delay;
		return 0;
	}

	return 1;
}

int fin_spi_set_loopback(fin_spi_num_t spi_num, bool enable){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].loopback = enable;
		return 0;
	}

	return 1;
}

int fin_spi_set_chip_select_mode(fin_spi_num_t spi_num, spi_cs_mode_t mode){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].cs_mode = mode;
		return 0;
	}

	return 1;
}

int fin_spi_set_chip_select_polarity(fin_spi_num_t spi_num, spi_cs_polarity_t polarity){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].cs_polarity = polarity;
		return 0;
	}

	return 1;
}

int fin_spi_set_chip_select_delay(fin_spi_num_t spi_num, uint8_t delay){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].cs_delay = delay;
		return 0;
	}

	return 1;
}

int fin_spi_set_slaves_num(fin_spi_num_t spi_num, uint8_t num){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){
		spi_map_tbl[spi_num].slaves = num;
		return 0;
	}

	return 1;
}

int fin_spi_send(fin_spi_num_t spi_num, uint8_t *tx_buf, size_t len){
	return fin_spi_send_receive(spi_num, tx_buf, NULL, len);
}

int fin_spi_send_receive(fin_spi_num_t spi_num, uint8_t *tx_buf, uint8_t *rx_buf, size_t len){
	if((spi_num >= 0 && spi_num < SPI_MAX_NO) && spi_map_tbl[spi_num].configured){
		
		qapi_SPIM_Config_t config;
		config.SPIM_Mode = (qapi_SPIM_Shift_Mode_t)spi_map_tbl[spi_num].mode;
		config.SPIM_CS_Polarity = (qapi_SPIM_CS_Polarity_t)spi_map_tbl[spi_num].cs_polarity;
		config.SPIM_endianness = (qapi_SPIM_Byte_Order_t)spi_map_tbl[spi_num].endian;
		config.SPIM_Bits_Per_Word = spi_map_tbl[spi_num].bpw;
		config.SPIM_Slave_Index = spi_map_tbl[spi_num].slaves;
		config.Clk_Freq_Hz = spi_map_tbl[spi_num].frequency;
		config.CS_Clk_Delay_Cycles = spi_map_tbl[spi_num].cs_delay;
		config.Inter_Word_Delay_Cycles = spi_map_tbl[spi_num].inter_word_delay;
		config.SPIM_CS_Mode = (qapi_SPIM_CS_Mode_t)spi_map_tbl[spi_num].cs_mode;
		config.loopback_Mode = (qbool_t)spi_map_tbl[spi_num].loopback;



		qapi_SPIM_Descriptor_t desc;
		desc.tx_buf = tx_buf;
		desc.rx_buf = rx_buf;
		desc.len = len;
	


		//check for lock
		if(__atomic_load_n(&spi_map_tbl[spi_num].lock,__ATOMIC_SEQ_CST) == 0){
			// lock
			spi_map_tbl[spi_num].status = -1;
			uint32_t expected;
			while(__atomic_compare_exchange_n(
				&spi_map_tbl[spi_num].lock,
				&expected,
				1,
				false,
				__ATOMIC_SEQ_CST,
				__ATOMIC_SEQ_CST) != 1);

			if(qapi_SPIM_Full_Duplex(spi_map_tbl[spi_num].handle, &config, &desc, 1, fin_spi_cb_func, &spi_map_tbl[spi_num].num, false) == QAPI_OK){
				//wait for signal
				do{
					tx_thread_sleep(5);
				}while(__atomic_load_n(&spi_map_tbl[spi_num].signal,__ATOMIC_SEQ_CST) == 0);
				//free signal
				while(__atomic_compare_exchange_n(
					&spi_map_tbl[spi_num].signal,
					&expected,
					0,
					false,
					__ATOMIC_SEQ_CST,
					__ATOMIC_SEQ_CST) != 1);

			}

			//free lock
			while(__atomic_compare_exchange_n(
				&spi_map_tbl[spi_num].lock,
				&expected,
				0,
				false,
				__ATOMIC_SEQ_CST,
				__ATOMIC_SEQ_CST) != 1);

			int status = (spi_map_tbl[spi_num].status == QAPI_SPI_COMPLETE) ?  0 : spi_map_tbl[spi_num].status;
			return status;

		}


	}

	return -1;
}

void fin_spi_config_dump(fin_spi_num_t spi_num){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO){

		printf("%s:\r\n"
			"Mode: %u\r\n"
			"CS Polarity: %u\r\n"
			"CS Delay: %u\r\n"
			"CS Mode: %u\r\n"
			"Endian: %u\r\n"
			"Bits per Word: %u\r\n"
			"Slaves: %u\r\n"
			"Frequency Hz: %u\r\n"
			"Inter Word Delay: %u\r\n"
			"Loopback: %u\r\n",
			spi_module_consts[spi_num].key,
			spi_map_tbl[spi_num].mode,
			spi_map_tbl[spi_num].cs_polarity,
			spi_map_tbl[spi_num].cs_delay,
			spi_map_tbl[spi_num].cs_mode,
			spi_map_tbl[spi_num].endian,
			spi_map_tbl[spi_num].bpw,
			spi_map_tbl[spi_num].slaves,
			spi_map_tbl[spi_num].frequency,			
			spi_map_tbl[spi_num].inter_word_delay,			
			spi_map_tbl[spi_num].loopback);
	}else{
		puts("NULL\r\n");
	}
}

const char *fin_spi_get_name(fin_spi_num_t spi_num){
	if(spi_num >= 0 && spi_num < SPI_MAX_NO)
		return spi_module_consts[spi_num].key;
	else
		return NULL;
}
/* #include fin_internal.h -> already included */

char *strdup(const char *s){
	char *str = NULL;
	if(s){
		str = malloc(strlen(s)+1);
		strcpy(str,s);
	}

	return str;
}
/* #include fin_internal.h -> already included */

_Noreturn void abort (void){
	tx_thread_terminate(tx_thread_identify());
	for(;;);
}


_Noreturn void exit (int arg){
	tx_thread_terminate(tx_thread_identify());
	for(;;);
}

_Noreturn void _Exit (int arg){
	tx_thread_terminate(tx_thread_identify());
	for(;;);
}

_Noreturn void quick_exit (int arg){
	tx_thread_terminate(tx_thread_identify());
	for(;;);
}

/* #include fin_internal.h -> already included */

struct tm *localtime (const time_t *t){
	static struct tm tm;

	memset(&tm,0,sizeof(struct tm));

	return &tm;
}

int gettimeofday(struct timeval *tv, void *tz){

	if (tv == NULL)	{
	  return -1;
	}
  
	qapi_time_get_t t;
	qapi_time_get(QAPI_TIME_SECS, &t);
  	
  	tv->tv_sec = t.time_secs;
  	tv->tv_usec = 0UL;

  	return 0;
}

uint64_t cputimeusecs(void){
	return tx_time_get();
}
/*
*
* @author :  Nikolas Karakotas
* @date   :  07/01/2021
*
*/
/* #include fin_internal.h -> already included */

#define UART_NO_MAX 3
#define RECV_BUF_SIZE	128

struct uart_map {
	uint8_t serial_num;
	int8_t index;
	uint32_t port_id;
	qapi_UART_Handle_t handle;
	uint8_t recv_buf[RECV_BUF_SIZE];
	volatile uint8_t recvd[RECV_BUF_SIZE];
	volatile uint32_t recvd_head;
	volatile uint32_t recvd_tail;
};

struct uart_map uart_map[UART_NO_MAX] = {
	{UART1, -1, QAPI_UART_PORT_001_E, NULL, 0},
	{UART2, -1, QAPI_UART_PORT_002_E, NULL, 0},
	{UART3, -1, QAPI_UART_PORT_003_E, NULL, 0}
};

static void uart_rx_cb(uint32_t num_bytes, void *cb_data){
	int8_t index = *(int8_t*)cb_data;

	for(int i=0; i < num_bytes; i++){
		uint32_t head = __atomic_fetch_add(&uart_map[index].recvd_head,1,__ATOMIC_RELAXED);
		if(head+1 >= RECV_BUF_SIZE-1){
			__atomic_store_n(&uart_map[index].recvd_head,0,__ATOMIC_RELAXED);
			head = 0;
		}
		__atomic_store_n (&uart_map[index].recvd[head], uart_map[index].recv_buf[i], __ATOMIC_RELAXED);
	}

}

static void uart_tx_cb(uint32_t num_bytes1, void *cb_data){

}


int fin_uart_config(fin_uart_t uart, uint32_t baud_rate, uint32_t stop_bits, uint32_t bits_per_char, uint32_t parity, uint32_t flow_ctrl){

	qapi_UART_Open_Config_t uart_cfg;
	int index = -1;

	for(int i=0; i < UART_NO_MAX; i++){
		if(uart_map[i].serial_num == uart){
			index = i;
			uart_map[i].index = i;
			break;
		}
	}

	if(index > -1 ){

		uart_cfg.baud_Rate			= baud_rate;
		uart_cfg.enable_Flow_Ctrl	= flow_ctrl;
		uart_cfg.bits_Per_Char		= bits_per_char;
		uart_cfg.enable_Loopback 	= 0;
		uart_cfg.num_Stop_Bits		= stop_bits;
		uart_cfg.parity_Mode 		= parity;
		uart_cfg.rx_CB_ISR			= (qapi_UART_Callback_Fn_t)&uart_rx_cb;
		uart_cfg.tx_CB_ISR			= (qapi_UART_Callback_Fn_t)&uart_tx_cb;


		if(qapi_UART_Open(&uart_map[index].handle, uart_map[index].port_id, &uart_cfg) == QAPI_OK && 
			qapi_UART_Power_On(uart_map[index].handle) == QAPI_OK){
				while(qapi_UART_Receive (uart_map[index].handle, uart_map[index].recv_buf, RECV_BUF_SIZE, &uart_map[index].index) != QAPI_OK); // queue as per doc
				uart_map[index].recvd_head = 0;
				uart_map[index].recvd_tail = 0;
				return 0;
		}

	}

	return 1;

}

int fin_uart_write(fin_uart_t uart, uint8_t *buf, size_t nbytes){

	if(buf){

		for(int i=0; i < UART_NO_MAX; i++){
			if(uart_map[i].serial_num == uart){
				return qapi_UART_Transmit(uart_map[i].handle, buf, nbytes, &uart_map[i].serial_num);
			}
		}

	}

	return 1;
}

int fin_uart_read(fin_uart_t uart, uint8_t *buf, size_t nbytes){

	if(buf){

		for(int i=0; i < UART_NO_MAX; i++){
			if(uart_map[i].serial_num == uart){
				uint32_t head = __atomic_load_n(&uart_map[i].recvd_head,__ATOMIC_RELAXED);
				uint32_t z=0;
				while(nbytes){
					if(uart_map[i].recvd_tail != head){
						uint32_t tail = uart_map[i].recvd_tail;
						buf[z++] = __atomic_load_n(&uart_map[i].recvd[tail],__ATOMIC_RELAXED);
						uart_map[i].recvd_tail++;
						if(uart_map[i].recvd_tail >= RECV_BUF_SIZE-1)
							uart_map[i].recvd_tail = 0;
					}
					nbytes--;
				}

				// queue again - crude way
				while(qapi_UART_Receive (uart_map[i].handle, uart_map[i].recv_buf, RECV_BUF_SIZE, &uart_map[i].index) != QAPI_OK); // queue as per doc

				return z;

			}
		}

	}	

	return 0;
}

int fin_uart_deconfig(fin_uart_t uart){
	for(int i=0; i < UART_NO_MAX; i++){
		if(uart_map[i].serial_num == uart){
			qapi_UART_Power_Off(uart_map[i].handle);
			return qapi_UART_Close(uart_map[i].handle);
		}
	}

	return 1;
}


int fin_uart_power_down(fin_uart_t uart){
	for(int i=0; i < UART_NO_MAX; i++){
		if(uart_map[i].serial_num == uart){
			return qapi_UART_Power_Off(uart_map[i].handle);
		}
	}

	return 1;
}

int fin_uart_power_up(fin_uart_t uart){
	for(int i=0; i < UART_NO_MAX; i++){
		if(uart_map[i].serial_num == uart){
			return qapi_UART_Power_On(uart_map[i].handle);
		}
	}

	return 1;
}

/* automatic undefs */
#undef RECV_BUF_SIZE
#undef UART_NO_MAX
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (info@paland.com)
//             2014-2019, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
//        embedded systems with a very limited resources. These routines are thread
//        safe and reentrant!
//        Use this instead of the bloated standard/newlib printf cause these use
//        malloc for printf (and may not be thread safe).
//
///////////////////////////////////////////////////////////////////////////////

#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <stddef.h>


// define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
// printf_config.h header file
// default: undefined
#ifdef PRINTF_INCLUDE_CONFIG_H
#include "printf_config.h"
#endif


// 'ntoa' conversion buffer size, this must be big enough to hold one converted
// numeric number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_NTOA_BUFFER_SIZE
#define PRINTF_NTOA_BUFFER_SIZE    32U
#endif

// 'ftoa' conversion buffer size, this must be big enough to hold one converted
// float number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_FTOA_BUFFER_SIZE
#define PRINTF_FTOA_BUFFER_SIZE    32U
#endif

// support for the floating point type (%f)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_FLOAT
#define PRINTF_SUPPORT_FLOAT
#endif

// support for exponential floating point notation (%e/%g)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
#define PRINTF_SUPPORT_EXPONENTIAL
#endif

// define the default floating point precision
// default: 6 digits
#ifndef PRINTF_DEFAULT_FLOAT_PRECISION
#define PRINTF_DEFAULT_FLOAT_PRECISION  6U
#endif

// define the largest float suitable to print with %f
// default: 1e9
#ifndef PRINTF_MAX_FLOAT
#define PRINTF_MAX_FLOAT  1e9
#endif

// support for the long long types (%llu or %p)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
#define PRINTF_SUPPORT_LONG_LONG
#endif

// support for the ptrdiff_t type (%t)
// ptrdiff_t is normally defined in <stddef.h> as long or long long type
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
#define PRINTF_SUPPORT_PTRDIFF_T
#endif

///////////////////////////////////////////////////////////////////////////////

// internal flag definitions
#define FLAGS_ZEROPAD   (1U <<  0U)
#define FLAGS_LEFT      (1U <<  1U)
#define FLAGS_PLUS      (1U <<  2U)
#define FLAGS_SPACE     (1U <<  3U)
#define FLAGS_HASH      (1U <<  4U)
#define FLAGS_UPPERCASE (1U <<  5U)
#define FLAGS_CHAR      (1U <<  6U)
#define FLAGS_SHORT     (1U <<  7U)
#define FLAGS_LONG      (1U <<  8U)
#define FLAGS_LONG_LONG (1U <<  9U)
#define FLAGS_PRECISION (1U << 10U)
#define FLAGS_ADAPT_EXP (1U << 11U)


// import float.h for DBL_MAX
#if defined(PRINTF_SUPPORT_FLOAT)
#include <float.h>
#endif


// output function type
typedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);


// wrapper (used as buffer) for output function type
typedef struct {
  void  (*fct)(char character, void* arg);
  void* arg;
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
    ((char*)buffer)[idx] = character;
  }
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
    _putchar(character);
  }
}


// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)idx; (void)maxlen;
  if (character) {
    // buffer is the output fct pointer
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  }
}


// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by 'maxsize'
static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
{
  const char* s;
  for (s = str; *s && maxsize--; ++s);
  return (unsigned int)(s - str);
}


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
  return (ch >= '0') && (ch <= '9');
}


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
  unsigned int i = 0U;
  while (_is_digit(**str)) {
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  }
  return i;
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    for (size_t i = len; i < width; i++) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  // reverse string
  while (len) {
    out(buf[--len], buffer, idx++, maxlen);
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
    while (idx - start_idx < width) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  return idx;
}


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
      len--;
      if (len && (base == 16U)) {
        len--;
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'x';
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'b';
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
#endif


// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
  double diff = 0.0;

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
#else
    return 0U;
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    buf[len++] = '0';
    prec--;
  }

  int whole = (int)value;
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
    ++frac;
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  }
  else if ((frac == 0U) || (frac & 1U)) {
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  }

  if (prec == 0U) {
    diff = value - (double)whole;
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
    }
  }
  else {
    unsigned int count = prec;
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
      --count;
      buf[len++] = (char)(48U + (frac % 10U));
      if (!(frac /= 10U)) {
        break;
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
      buf[len++] = '0';
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
      // add decimal
      buf[len++] = '.';
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
    if (!(whole /= 10)) {
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_FTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
    value = -value;
  }

  // default precision
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }

  // determine the decimal exponent
  // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
  union {
    uint64_t U;
    double   F;
  } conv;

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  // correct for rounding errors
  if (value < conv.F) {
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
      if ((int)prec > expval) {
        prec = (unsigned)((int)prec - expval - 1);
      }
      else {
        prec = 0;
      }
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
      // no characters in exponent
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
        --prec;
      }
    }
  }

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
    value /= conv.F;
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);

  // output the exponent part
  if (minwidth) {
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
    }
  }
  return idx;
}
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  }

  while (*format)
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
      // no
      out(*format, buffer, idx++, maxlen);
      format++;
      continue;
    }
    else {
      // yes, evaluate it
      format++;
    }

    // evaluate flags
    flags = 0U;
    do {
      switch (*format) {
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
        default :                                   n = 0U; break;
      }
    } while (n);

    // evaluate width field
    width = 0U;
    if (_is_digit(*format)) {
      width = _atoi(&format);
    }
    else if (*format == '*') {
      const int w = va_arg(va, int);
      if (w < 0) {
        flags |= FLAGS_LEFT;    // reverse padding
        width = (unsigned int)-w;
      }
      else {
        width = (unsigned int)w;
      }
      format++;
    }

    // evaluate precision field
    precision = 0U;
    if (*format == '.') {
      flags |= FLAGS_PRECISION;
      format++;
      if (_is_digit(*format)) {
        precision = _atoi(&format);
      }
      else if (*format == '*') {
        const int prec = (int)va_arg(va, int);
        precision = prec > 0 ? (unsigned int)prec : 0U;
        format++;
      }
    }

    // evaluate length field
    switch (*format) {
      case 'l' :
        flags |= FLAGS_LONG;
        format++;
        if (*format == 'l') {
          flags |= FLAGS_LONG_LONG;
          format++;
        }
        break;
      case 'h' :
        flags |= FLAGS_SHORT;
        format++;
        if (*format == 'h') {
          flags |= FLAGS_CHAR;
          format++;
        }
        break;
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
      default :
        break;
    }

    // evaluate specifier
    switch (*format) {
      case 'd' :
      case 'i' :
      case 'u' :
      case 'x' :
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
          base = 16U;
        }
        else if (*format == 'o') {
          base =  8U;
        }
        else if (*format == 'b') {
          base =  2U;
        }
        else {
          base = 10U;
          flags &= ~FLAGS_HASH;   // no hash for dec format
        }
        // uppercase
        if (*format == 'X') {
          flags |= FLAGS_UPPERCASE;
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
          flags &= ~FLAGS_ZEROPAD;
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
          // signed
          if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
#endif
          }
          else if (flags & FLAGS_LONG) {
            const long value = va_arg(va, long);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
#endif
          }
          else if (flags & FLAGS_LONG) {
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
          }
        }
        format++;
        break;
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
        format++;
        break;
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
      case 'e':
      case 'E':
      case 'g':
      case 'G':
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
        format++;
        break;
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
        // post padding
        if (flags & FLAGS_LEFT) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        format++;
        break;
      }

      case 's' : {
        const char* p = va_arg(va, char*);
        p = (p == NULL) ? "(null)" : p;
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
        // pre padding
        if (flags & FLAGS_PRECISION) {
          l = (l < precision ? l : precision);
        }
        if (!(flags & FLAGS_LEFT)) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
          out(*(p++), buffer, idx++, maxlen);
        }
        // post padding
        if (flags & FLAGS_LEFT) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        format++;
        break;
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
        break;
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
        format++;
        break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
}


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
  va_list va;
  va_start(va, format);
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  va_end(va);
  return ret;
}


int sprintf_(char* buffer, const char* format, ...)
{
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  va_end(va);
  return ret;
}


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  va_end(va);
  return ret;
}


int vprintf_(const char* format, va_list va)
{
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
}


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  return _vsnprintf(_out_buffer, buffer, count, format, va);
}


int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  va_list va;
  va_start(va, format);
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  va_end(va);
  return ret;
}

/* automatic undefs */
#undef FLAGS_ADAPT_EXP
#undef FLAGS_CHAR
#undef FLAGS_HASH
#undef FLAGS_LEFT
#undef FLAGS_LONG
#undef FLAGS_LONG_LONG
#undef FLAGS_PLUS
#undef FLAGS_PRECISION
#undef FLAGS_SHORT
#undef FLAGS_SPACE
#undef FLAGS_UPPERCASE
#undef FLAGS_ZEROPAD
#undef PRINTF_DEFAULT_FLOAT_PRECISION
#undef PRINTF_FTOA_BUFFER_SIZE
#undef PRINTF_MAX_FLOAT
#undef PRINTF_NTOA_BUFFER_SIZE
#undef PRINTF_SUPPORT_EXPONENTIAL
#undef PRINTF_SUPPORT_FLOAT
#undef PRINTF_SUPPORT_LONG_LONG
#undef PRINTF_SUPPORT_PTRDIFF_T
